/// Inspector — bottom-panel diagnostic tool with tabbed panels.
/// Per-surface: each Surface owns its own Inspector state.
/// Panels: 0=Screen, 1=Modes, 2=Keyboard, 3=Terminal IO.
/// Matches Ghostty's inspector layout.

import "std/list"
import "std/string"
import "terminal"
import "cell"
import "input"

// ============================================================================
// Panel constants
// ============================================================================

const PANEL_SCREEN: i64 = 0
const PANEL_MODES: i64 = 1
const PANEL_KEYBOARD: i64 = 2
const PANEL_TERMIO: i64 = 3

const MAX_KEY_EVENTS: i64 = 100
const MAX_VT_EVENTS: i64 = 200

// ============================================================================
// VT sequence kind constants
// ============================================================================

const VT_CSI: i64 = 0
const VT_OSC: i64 = 1
const VT_ESC: i64 = 2
const VT_C0: i64 = 3
const VT_SGR: i64 = 4

// ============================================================================
// KeyRecord — a single recorded key event
// ============================================================================

struct KeyRecord {
    key: i64,
    mods: i64,
    pty_bytes: List(i64),
    pty_len: i64,
}

// ============================================================================
// VtRecord — a single recorded VT sequence
// ============================================================================

struct VtRecord {
    kind: i64,
    params: string,
    raw_bytes: string,
}

// ============================================================================
// Inspector — per-surface diagnostic panel
// ============================================================================

struct Inspector {
    active: bool,
    panel: i64,
    grid: TerminalGrid,
    cols: i64,
    rows: i64,

    // Keyboard panel
    key_events: List(KeyRecord),
    key_scroll: i64,

    // Terminal IO panel
    vt_events: List(VtRecord),
    vt_scroll: i64,

    // Screen/Modes panel scroll
    screen_scroll: i64,
    modes_scroll: i64,

    static fn init(rows: i64, cols: i64) Inspector {
        var key_events: List(KeyRecord) = .{}
        var vt_events: List(VtRecord) = .{}

        return Inspector {
            active: false,
            panel: PANEL_SCREEN,
            grid: TerminalGrid.init(rows, cols),
            cols: cols,
            rows: rows,
            key_events: key_events,
            key_scroll: 0,
            vt_events: vt_events,
            vt_scroll: 0,
            screen_scroll: 0,
            modes_scroll: 0,
        }
    }

    fn toggle() void {
        self.active = !self.active
        if (self.active) {
            self.rebuild()
        }
    }

    fn setPanel(p: i64) void {
        if (p < 0 or p > 3) { return }
        self.panel = p
        self.key_scroll = 0
        self.vt_scroll = 0
        self.screen_scroll = 0
        self.modes_scroll = 0
        if (self.active) {
            self.rebuild()
        }
    }

    fn resize(new_rows: i64, new_cols: i64) void {
        self.rows = new_rows
        self.cols = new_cols
        self.grid = TerminalGrid.init(new_rows, new_cols)
        if (self.active) {
            self.rebuild()
        }
    }

    fn scroll(delta: i64) void {
        if (self.panel == PANEL_KEYBOARD) {
            self.key_scroll = self.key_scroll + delta
            if (self.key_scroll < 0) { self.key_scroll = 0 }
            const max_scroll = self.key_events.count - (self.rows - 2)
            if (max_scroll < 0) {
                self.key_scroll = 0
            } else if (self.key_scroll > max_scroll) {
                self.key_scroll = max_scroll
            }
        } else if (self.panel == PANEL_TERMIO) {
            self.vt_scroll = self.vt_scroll + delta
            if (self.vt_scroll < 0) { self.vt_scroll = 0 }
            const max_scroll = self.vt_events.count - (self.rows - 2)
            if (max_scroll < 0) {
                self.vt_scroll = 0
            } else if (self.vt_scroll > max_scroll) {
                self.vt_scroll = max_scroll
            }
        } else if (self.panel == PANEL_SCREEN) {
            self.screen_scroll = self.screen_scroll + delta
            if (self.screen_scroll < 0) { self.screen_scroll = 0 }
            const max_scroll: i64 = 25 - self.rows
            if (max_scroll < 0) {
                self.screen_scroll = 0
            } else if (self.screen_scroll > max_scroll) {
                self.screen_scroll = max_scroll
            }
        } else if (self.panel == PANEL_MODES) {
            self.modes_scroll = self.modes_scroll + delta
            if (self.modes_scroll < 0) { self.modes_scroll = 0 }
            const max_scroll: i64 = 20 - (self.rows - 2)
            if (max_scroll < 0) {
                self.modes_scroll = 0
            } else if (self.modes_scroll > max_scroll) {
                self.modes_scroll = max_scroll
            }
        }
        if (self.active) {
            self.rebuild()
        }
    }

    /// Total scrollable content rows for the current panel.
    /// Returns the number of data rows (excluding the 5-row header).
    fn contentRows() i64 {
        if (self.panel == PANEL_KEYBOARD) { return self.key_events.count }
        if (self.panel == PANEL_TERMIO) { return self.vt_events.count }
        if (self.panel == PANEL_SCREEN) { return 25 }
        if (self.panel == PANEL_MODES) { return 20 }
        return 0
    }

    /// Current scroll offset for the active panel.
    fn scrollOffset() i64 {
        if (self.panel == PANEL_KEYBOARD) { return self.key_scroll }
        if (self.panel == PANEL_TERMIO) { return self.vt_scroll }
        if (self.panel == PANEL_SCREEN) { return self.screen_scroll }
        if (self.panel == PANEL_MODES) { return self.modes_scroll }
        return 0
    }

    /// Set absolute scroll offset for the active panel.
    fn setScrollOffset(offset: i64) void {
        if (self.panel == PANEL_KEYBOARD) {
            self.key_scroll = offset
            if (self.key_scroll < 0) { self.key_scroll = 0 }
            const max_scroll = self.key_events.count - (self.rows - 2)
            if (max_scroll < 0) {
                self.key_scroll = 0
            } else if (self.key_scroll > max_scroll) {
                self.key_scroll = max_scroll
            }
        } else if (self.panel == PANEL_TERMIO) {
            self.vt_scroll = offset
            if (self.vt_scroll < 0) { self.vt_scroll = 0 }
            const max_scroll = self.vt_events.count - (self.rows - 2)
            if (max_scroll < 0) {
                self.vt_scroll = 0
            } else if (self.vt_scroll > max_scroll) {
                self.vt_scroll = max_scroll
            }
        } else if (self.panel == PANEL_SCREEN) {
            self.screen_scroll = offset
            if (self.screen_scroll < 0) { self.screen_scroll = 0 }
            const max_scroll: i64 = 25 - self.rows
            if (max_scroll < 0) {
                self.screen_scroll = 0
            } else if (self.screen_scroll > max_scroll) {
                self.screen_scroll = max_scroll
            }
        } else if (self.panel == PANEL_MODES) {
            self.modes_scroll = offset
            if (self.modes_scroll < 0) { self.modes_scroll = 0 }
            const max_scroll: i64 = 20 - (self.rows - 2)
            if (max_scroll < 0) {
                self.modes_scroll = 0
            } else if (self.modes_scroll > max_scroll) {
                self.modes_scroll = max_scroll
            }
        }
        if (self.active) {
            self.rebuild()
        }
    }

    // ========================================================================
    // Recording
    // ========================================================================

    fn recordKeyEvent(key: i64, mods: i64, bytes: List(i64)) void {
        if (!self.active) { return }

        const rec = KeyRecord {
            key: key,
            mods: mods,
            pty_bytes: bytes,
            pty_len: bytes.count,
        }
        self.key_events.append(rec)

        // Trim to max
        while (self.key_events.count > MAX_KEY_EVENTS) {
            var new_events: List(KeyRecord) = .{}
            var i: i64 = 1
            while (i < self.key_events.count) {
                new_events.append(self.key_events.get(i))
                i += 1
            }
            self.key_events = new_events
        }

        self.rebuild()
    }

    fn recordVtEvent(kind: i64, params: string, raw_bytes: string) void {
        if (!self.active) { return }

        const rec = VtRecord {
            kind: kind,
            params: params,
            raw_bytes: raw_bytes,
        }
        self.vt_events.append(rec)

        // Trim to max
        while (self.vt_events.count > MAX_VT_EVENTS) {
            var new_events: List(VtRecord) = .{}
            var i: i64 = 1
            while (i < self.vt_events.count) {
                new_events.append(self.vt_events.get(i))
                i += 1
            }
            self.vt_events = new_events
        }

        self.rebuild()
    }

    // ========================================================================
    // Rendering
    // ========================================================================

    fn rebuild() void {
        self.grid = TerminalGrid.init(self.rows, self.cols)

        // Dark background
        for row in 0..self.rows {
            for col in 0..self.cols {
                const c = self.grid.getCell(row, col)
                c.bg_r = 30
                c.bg_g = 30
                c.bg_b = 35
            }
        }

        // Tab bar is now a native NSSegmentedControl in Swift (like Ghostty's ImGui tabs).
        // The grid is entirely content — no separator or tab rendering here.
        switch (self.panel) {
            PANEL_SCREEN => self.rebuildScreen(),
            PANEL_MODES => self.rebuildModes(),
            PANEL_KEYBOARD => self.rebuildKeyboard(),
            PANEL_TERMIO => self.rebuildTermio(),
            else => {},
        }
    }

    // ========================================================================
    // Screen Panel — Terminal state info (Ghostty's "Terminal" tab)
    // ========================================================================

    fn rebuildScreen() void {
        // Placeholder: use rebuildScreenFrom() with terminal pointer
        self.writeStr(1, 2, "Waiting for terminal state...", 100, 100, 110)
    }

    fn rebuildScreenFrom(terminal: *TerminalState) void {
        // Re-render: clear and redraw
        self.grid = TerminalGrid.init(self.rows, self.cols)
        for row in 0..self.rows {
            for col in 0..self.cols {
                const c = self.grid.getCell(row, col)
                c.bg_r = 30
                c.bg_g = 30
                c.bg_b = 35
            }
        }

        const label_col: i64 = 2
        const value_col: i64 = 22
        // Content starts at row 0, offset by scroll
        const scroll = self.screen_scroll
        var row: i64 = 0 - scroll

        // -- Grid section --
        self.writeStr(row, 2, "Grid", 200, 170, 100)
        row += 1

        var sb1: StringBuilder = .{}
        sb1.appendInt(terminal.grid.cols)
        sb1.append("c x ")
        sb1.appendInt(terminal.grid.rows)
        sb1.append("r")
        self.writeStr(row, label_col + 2, "Size", 130, 130, 140)
        self.writeStr(row, value_col, sb1.toString(), 220, 220, 220)
        row += 1

        var sb2: StringBuilder = .{}
        sb2.appendInt(terminal.grid.active_start)
        sb2.append(" lines")
        self.writeStr(row, label_col + 2, "Scrollback", 130, 130, 140)
        self.writeStr(row, value_col, sb2.toString(), 220, 220, 220)
        row += 1

        var sb3: StringBuilder = .{}
        sb3.appendInt(terminal.scroll_top)
        sb3.append("..")
        sb3.appendInt(terminal.scroll_bottom)
        self.writeStr(row, label_col + 2, "Scroll Region", 130, 130, 140)
        self.writeStr(row, value_col, sb3.toString(), 220, 220, 220)
        row += 2

        // -- Cursor section --
        self.writeStr(row, 2, "Cursor", 200, 170, 100)
        row += 1

        var sb4: StringBuilder = .{}
        sb4.append("(")
        sb4.appendInt(terminal.cursor_col)
        sb4.append(", ")
        sb4.appendInt(terminal.cursor_row)
        sb4.append(")")
        self.writeStr(row, label_col + 2, "Position", 130, 130, 140)
        self.writeStr(row, value_col, sb4.toString(), 220, 220, 220)
        row += 1

        self.writeStr(row, label_col + 2, "Shape", 130, 130, 140)
        self.writeStr(row, value_col, cursorShapeName(terminal.cursor_shape), 220, 220, 220)
        row += 1

        self.writeStr(row, label_col + 2, "Visible", 130, 130, 140)
        if (terminal.cursor_visible) {
            self.writeStr(row, value_col, "yes", 100, 220, 100)
        } else {
            self.writeStr(row, value_col, "no", 220, 100, 100)
        }
        row += 1

        self.writeStr(row, label_col + 2, "Pending Wrap", 130, 130, 140)
        if (terminal.pending_wrap) {
            self.writeStr(row, value_col, "yes", 220, 180, 80)
        } else {
            self.writeStr(row, value_col, "no", 150, 150, 150)
        }
        row += 2

        // -- Colors section --
        self.writeStr(row, 2, "Colors", 200, 170, 100)
        row += 1

        var sb5: StringBuilder = .{}
        sb5.append("rgb(")
        sb5.appendInt(terminal.fg_r)
        sb5.append(", ")
        sb5.appendInt(terminal.fg_g)
        sb5.append(", ")
        sb5.appendInt(terminal.fg_b)
        sb5.append(")")
        self.writeStr(row, label_col + 2, "Foreground", 130, 130, 140)
        self.writeStr(row, value_col, sb5.toString(), 220, 220, 220)
        // Color swatch
        self.writeColorSwatch(row, value_col + @lenOf(sb5.toString()) + 1, terminal.fg_r, terminal.fg_g, terminal.fg_b)
        row += 1

        var sb6: StringBuilder = .{}
        sb6.append("rgb(")
        sb6.appendInt(terminal.bg_r)
        sb6.append(", ")
        sb6.appendInt(terminal.bg_g)
        sb6.append(", ")
        sb6.appendInt(terminal.bg_b)
        sb6.append(")")
        self.writeStr(row, label_col + 2, "Background", 130, 130, 140)
        self.writeStr(row, value_col, sb6.toString(), 220, 220, 220)
        self.writeColorSwatch(row, value_col + @lenOf(sb6.toString()) + 1, terminal.bg_r, terminal.bg_g, terminal.bg_b)
        row += 2

        // -- SGR section --
        self.writeStr(row, 2, "SGR Attributes", 200, 170, 100)
        row += 1

        var sb7: StringBuilder = .{}
        if (terminal.bold) { sb7.append("bold ") }
        if (terminal.dim) { sb7.append("dim ") }
        if (terminal.italic) { sb7.append("italic ") }
        if (terminal.underline) { sb7.append("underline ") }
        if (terminal.inverse) { sb7.append("inverse ") }
        if (terminal.strikethrough) { sb7.append("strikethrough ") }
        if (@lenOf(sb7.toString()) == 0) { sb7.append("(none)") }
        self.writeStr(row, label_col + 2, sb7.toString(), 200, 200, 200)
        row += 2

        // -- Charset section --
        self.writeStr(row, 2, "Charset", 200, 170, 100)
        row += 1

        var sb8: StringBuilder = .{}
        sb8.append("G0=")
        sb8.appendInt(terminal.charset_g0)
        sb8.append("  G1=")
        sb8.appendInt(terminal.charset_g1)
        sb8.append("  active=G")
        sb8.appendInt(terminal.active_charset)
        self.writeStr(row, label_col + 2, sb8.toString(), 200, 200, 200)
    }

    // ========================================================================
    // Modes Panel — All terminal mode flags (Ghostty's "Modes" tab)
    // ========================================================================

    fn rebuildModes() void {
        // Placeholder: use rebuildModesFrom() with terminal pointer
        self.writeStr(1, 2, "Waiting for terminal state...", 100, 100, 110)
    }

    fn rebuildModesFrom(terminal: *TerminalState) void {
        // Re-render
        self.grid = TerminalGrid.init(self.rows, self.cols)
        for row in 0..self.rows {
            for col in 0..self.cols {
                const c = self.grid.getCell(row, col)
                c.bg_r = 30
                c.bg_g = 30
                c.bg_b = 35
            }
        }

        // Build mode entries with scroll offset applied
        const mode_col: i64 = 4
        const state_col: i64 = 30
        const scroll = self.modes_scroll

        // Column headers rendered AFTER content (painter's algorithm — headers stay fixed)
        var row: i64 = 2 - scroll

        // DEC private modes
        self.writeModeRow(row, mode_col, "?1    App Cursor Keys", terminal.mode_app_cursor, state_col)
        row += 1
        self.writeModeRow(row, mode_col, "?7    Wraparound", terminal.mode_wraparound, state_col)
        row += 1
        self.writeModeRow(row, mode_col, "?6    Origin Mode", terminal.mode_origin, state_col)
        row += 1
        self.writeModeRow(row, mode_col, "?25   Cursor Visible", terminal.cursor_visible, state_col)
        row += 1
        self.writeModeRow(row, mode_col, "?47   Alt Screen", terminal.mode_alt_screen, state_col)
        row += 1
        self.writeModeRow(row, mode_col, "?1000 Mouse Tracking", terminal.mode_mouse_tracking != 0, state_col)
        row += 1
        self.writeModeRow(row, mode_col, "?1004 Focus Events", terminal.mode_focus_events, state_col)
        row += 1
        self.writeModeRow(row, mode_col, "?1007 Alt Scroll", terminal.mode_mouse_alt_scroll, state_col)
        row += 1
        self.writeModeRow(row, mode_col, "?2004 Bracketed Paste", terminal.mode_bracketed_paste, state_col)
        row += 1
        self.writeModeRow(row, mode_col, "?2026 Sync Output", terminal.mode_sync_output, state_col)
        row += 2

        // Mouse details
        self.writeStr(row, 2, "Mouse", 200, 170, 100)
        row += 1

        var sb1: StringBuilder = .{}
        sb1.appendInt(terminal.mode_mouse_tracking)
        self.writeStr(row, mode_col, "Tracking Mode", 130, 130, 140)
        self.writeStr(row, state_col, sb1.toString(), 220, 220, 220)
        row += 1

        var sb2: StringBuilder = .{}
        sb2.appendInt(terminal.mode_mouse_format)
        self.writeStr(row, mode_col, "Format", 130, 130, 140)
        self.writeStr(row, state_col, sb2.toString(), 220, 220, 220)

        // Fixed column headers rendered LAST so they stay on top of scrolled content
        self.clearRow(0)
        self.writeStr(0, 2, "Mode", 200, 170, 100)
        self.writeStr(0, 30, "State", 200, 170, 100)
        self.clearRow(1)
        self.renderSeparator(1)
    }

    fn writeModeRow(row: i64, col: i64, name: string, on: bool, state_col: i64) void {
        self.writeStr(row, col, name, 180, 180, 190)
        if (on) {
            self.writeStr(row, state_col, "ON", 80, 220, 80)
        } else {
            self.writeStr(row, state_col, "off", 120, 120, 120)
        }
    }

    // ========================================================================
    // Keyboard Panel — Key event stream (Ghostty's "Keyboard" tab)
    // ========================================================================

    fn rebuildKeyboard() void {
        // Events (most recent at top), starting at row 2 (below fixed headers)
        const header_rows: i64 = 2
        const display_rows = self.rows - header_rows
        if (display_rows <= 0) { return }

        var i: i64 = 0
        while (i < display_rows and i + self.key_scroll < self.key_events.count) {
            const event_idx = self.key_events.count - 1 - i - self.key_scroll
            if (event_idx < 0) { break }
            const rec = self.key_events.get(event_idx)
            const display_row = i + header_rows

            // Alternate row background
            if (i % 2 == 1) {
                var ac: i64 = 0
                while (ac < self.cols) {
                    const cell = self.grid.getCell(display_row, ac)
                    cell.bg_r = 35
                    cell.bg_g = 35
                    cell.bg_b = 42
                    ac += 1
                }
            }

            // Index number
            var idx_sb: StringBuilder = .{}
            idx_sb.appendInt(self.key_events.count - event_idx)
            self.writeStr(display_row, 2, idx_sb.toString(), 90, 90, 100)

            // Key name
            self.writeStr(display_row, 6, keyName(rec.key), 220, 220, 230)

            // Mods
            self.writeStr(display_row, 20, modsString(rec.mods), 160, 160, 170)

            // PTY bytes
            self.writeStr(display_row, 30, bytesHex(rec.pty_bytes), 100, 200, 120)

            i += 1
        }

        // Fixed column headers rendered LAST (painter's algorithm)
        self.clearRow(0)
        self.writeStr(0, 2, "#", 130, 130, 140)
        self.writeStr(0, 6, "Key", 130, 130, 140)
        self.writeStr(0, 20, "Mods", 130, 130, 140)
        self.writeStr(0, 30, "PTY Bytes", 130, 130, 140)
        self.clearRow(1)
        self.renderSeparator(1)
    }

    // ========================================================================
    // Terminal IO Panel — VT sequence stream (Ghostty's "Terminal IO" tab)
    // ========================================================================

    fn rebuildTermio() void {
        // Events (most recent at top), starting at row 2 (below fixed headers)
        const header_rows: i64 = 2
        const display_rows = self.rows - header_rows
        if (display_rows <= 0) { return }

        var i: i64 = 0
        while (i < display_rows and i + self.vt_scroll < self.vt_events.count) {
            const event_idx = self.vt_events.count - 1 - i - self.vt_scroll
            if (event_idx < 0) { break }
            const rec = self.vt_events.get(event_idx)
            const display_row = i + header_rows

            // Alternate row background
            if (i % 2 == 1) {
                var ac: i64 = 0
                while (ac < self.cols) {
                    const cell = self.grid.getCell(display_row, ac)
                    cell.bg_r = 35
                    cell.bg_g = 35
                    cell.bg_b = 42
                    ac += 1
                }
            }

            // Index
            var idx_sb: StringBuilder = .{}
            idx_sb.appendInt(self.vt_events.count - event_idx)
            self.writeStr(display_row, 2, idx_sb.toString(), 90, 90, 100)

            // Kind name — color-coded by type
            var kind_r: i64 = 150
            var kind_g: i64 = 200
            var kind_b: i64 = 255
            if (rec.kind == VT_C0) {
                kind_r = 255
                kind_g = 150
                kind_b = 100
            } else if (rec.kind == VT_SGR) {
                kind_r = 200
                kind_g = 150
                kind_b = 255
            } else if (rec.kind == VT_OSC) {
                kind_r = 100
                kind_g = 255
                kind_b = 200
            } else if (rec.kind == VT_ESC) {
                kind_r = 255
                kind_g = 200
                kind_b = 100
            }
            self.writeStr(display_row, 7, vtKindName(rec.kind), kind_r, kind_g, kind_b)

            // Params
            self.writeStr(display_row, 14, rec.params, 220, 220, 230)

            // Raw bytes / description
            self.writeStr(display_row, 40, rec.raw_bytes, 100, 200, 120)

            i += 1
        }

        // Fixed column headers rendered LAST (painter's algorithm)
        self.clearRow(0)
        self.writeStr(0, 2, "#", 130, 130, 140)
        self.writeStr(0, 7, "Kind", 130, 130, 140)
        self.writeStr(0, 14, "Params", 130, 130, 140)
        self.writeStr(0, 40, "Description", 130, 130, 140)
        self.clearRow(1)
        self.renderSeparator(1)
    }

    // ========================================================================
    // Helpers
    // ========================================================================

    /// Clear a row to the default dark background.
    fn clearRow(row: i64) void {
        if (row < 0 or row >= self.rows) { return }
        for col in 0..self.cols {
            const c = self.grid.getCell(row, col)
            c.codepoint = 0
            c.fg_r = 0
            c.fg_g = 0
            c.fg_b = 0
            c.bg_r = 30
            c.bg_g = 30
            c.bg_b = 35
        }
    }

    /// Render a horizontal separator line at the given row.
    fn renderSeparator(row: i64) void {
        if (row < 0 or row >= self.rows) { return }
        for col in 0..self.cols {
            const c = self.grid.getCell(row, col)
            c.codepoint = 0x2500  // ─
            c.fg_r = 50
            c.fg_g = 50
            c.fg_b = 60
        }
    }

    fn writeStr(row: i64, col: i64, s: string, r: i64, g: i64, b: i64) i64 {
        if (row < 0 or row >= self.rows) { return col }
        var i: i64 = 0
        while (i < @lenOf(s) and col + i < self.cols) {
            const c = self.grid.getCell(row, col + i)
            c.codepoint = @intToPtr(*u8, @ptrOf(s) + i).*
            c.fg_r = r
            c.fg_g = g
            c.fg_b = b
            i += 1
        }
        return col + i
    }

    fn writeColorSwatch(row: i64, col: i64, r: i64, g: i64, b: i64) void {
        if (row < 0 or row >= self.rows or col >= self.cols) { return }
        // Write two block chars with the actual color
        var i: i64 = 0
        while (i < 2 and col + i < self.cols) {
            const c = self.grid.getCell(row, col + i)
            c.codepoint = 0x2588  // █ full block
            c.fg_r = r
            c.fg_g = g
            c.fg_b = b
            i += 1
        }
    }
}

// ============================================================================
// Formatting helpers
// ============================================================================

fn cursorShapeName(shape: i64) string {
    return switch (shape) {
        0 => "default",
        1 => "blinking block",
        2 => "steady block",
        3 => "blinking underline",
        4 => "steady underline",
        5 => "blinking bar",
        6 => "steady bar",
        else => "unknown",
    }
}

fn vtKindName(kind: i64) string {
    return switch (kind) {
        VT_CSI => "CSI",
        VT_OSC => "OSC",
        VT_ESC => "ESC",
        VT_C0 => "C0",
        VT_SGR => "SGR",
        else => "???",
    }
}

fn keyName(key: i64) string {
    return switch (key) {
        KEY_TAB => "Tab",
        KEY_ENTER => "Enter",
        KEY_ESCAPE => "Esc",
        KEY_BACKSPACE => "Bksp",
        KEY_DELETE => "Del",
        KEY_ARROW_UP => "Up",
        KEY_ARROW_DOWN => "Down",
        KEY_ARROW_LEFT => "Left",
        KEY_ARROW_RIGHT => "Right",
        KEY_HOME => "Home",
        KEY_END => "End",
        KEY_PAGE_UP => "PgUp",
        KEY_PAGE_DOWN => "PgDn",
        KEY_F1 => "F1",
        KEY_F2 => "F2",
        KEY_F3 => "F3",
        KEY_F4 => "F4",
        KEY_F5 => "F5",
        KEY_F6 => "F6",
        KEY_F7 => "F7",
        KEY_F8 => "F8",
        KEY_F9 => "F9",
        KEY_F10 => "F10",
        KEY_F11 => "F11",
        KEY_F12 => "F12",
        ' ' => "Space",
        else => {
            // Printable ASCII
            if (key >= 33 and key <= 126) {
                var sb: StringBuilder = .{}
                sb.appendByte('\'')
                sb.appendByte(key)
                sb.appendByte('\'')
                return sb.toString()
            }
            // Unknown key — show as number
            var sb: StringBuilder = .{}
            sb.append("key:")
            sb.appendInt(key)
            return sb.toString()
        },
    }
}

fn modsString(mods: i64) string {
    if (mods == 0) { return "-" }
    var sb: StringBuilder = .{}
    var first: bool = true
    if ((mods & MOD_CTRL) != 0) {
        if (!first) { sb.appendByte('+') }
        sb.append("Ctrl")
        first = false
    }
    if ((mods & MOD_SHIFT) != 0) {
        if (!first) { sb.appendByte('+') }
        sb.append("Shift")
        first = false
    }
    if ((mods & MOD_ALT) != 0) {
        if (!first) { sb.appendByte('+') }
        sb.append("Alt")
        first = false
    }
    if ((mods & MOD_SUPER) != 0) {
        if (!first) { sb.appendByte('+') }
        sb.append("Super")
        first = false
    }
    return sb.toString()
}

fn bytesHex(bytes: List(i64)) string {
    if (bytes.count == 0) { return "(none)" }
    var sb: StringBuilder = .{}
    var i: i64 = 0
    while (i < bytes.count) {
        if (i > 0) { sb.appendByte(' ') }
        const b = bytes.get(i)
        if (b == 0x1b) {
            sb.append("ESC")
        } else if (b < 32) {
            sb.appendByte('^')
            sb.appendByte(b + 64)
        } else if (b >= 32 and b <= 126) {
            sb.appendByte(b)
        } else {
            sb.append("0x")
            var hi = b / 16
            var lo = b % 16
            if (hi < 10) { sb.appendByte('0' + hi) } else { sb.appendByte('a' + hi - 10) }
            if (lo < 10) { sb.appendByte('0' + lo) } else { sb.appendByte('a' + lo - 10) }
        }
        i += 1
    }
    return sb.toString()
}

/// Format a C0 control byte as a human-readable name.
fn c0Name(b: i64) string {
    return switch (b) {
        0x07 => "BEL",
        0x08 => "BS",
        0x09 => "HT",
        0x0A => "LF",
        0x0B => "VT",
        0x0C => "FF",
        0x0D => "CR",
        0x0E => "SO",
        0x0F => "SI",
        else => {
            var sb: StringBuilder = .{}
            sb.append("^")
            sb.appendByte(b + 64)
            return sb.toString()
        },
    }
}
