/// Key Inspector — records key events and renders a diagnostic overlay.
/// Shows what key events are received and what PTY bytes are sent.

import "std/list"
import "std/string"
import "terminal"
import "cell"
import "input"

// ============================================================================
// KeyRecord — a single recorded key event
// ============================================================================

struct KeyRecord {
    key: i64,
    mods: i64,
    pty_bytes: List(i64),
    pty_len: i64,
}

// ============================================================================
// KeyInspector — overlay display of recent key events
// ============================================================================

const INSPECTOR_MAX_EVENTS: i64 = 10
const INSPECTOR_ROWS: i64 = 12

struct KeyInspector {
    active: bool,
    events: List(KeyRecord),
    overlay: TerminalGrid,
    overlay_cols: i64,

    static fn init() KeyInspector {
        var events: List(KeyRecord) = .{}

        return KeyInspector {
            active: false,
            events: events,
            overlay: TerminalGrid.init(INSPECTOR_ROWS, 80),
            overlay_cols: 80,
        }
    }

    fn toggle() void {
        self.active = !self.active
        if (self.active) {
            self.rebuildOverlay()
        }
    }

    fn recordEvent(key: i64, mods: i64, bytes: List(i64)) void {
        if (!self.active) { return }

        const rec = KeyRecord {
            key: key,
            mods: mods,
            pty_bytes: bytes,
            pty_len: bytes.count,
        }
        self.events.append(rec)

        // Trim to max events
        while (self.events.count > INSPECTOR_MAX_EVENTS) {
            // Shift events: remove oldest by rebuilding
            var new_events: List(KeyRecord) = .{}
            var i: i64 = 1
            while (i < self.events.count) {
                new_events.append(self.events.get(i))
                i += 1
            }
            self.events = new_events
        }

        self.rebuildOverlay()
    }

    fn resizeOverlay(cols: i64) void {
        self.overlay_cols = cols
        if (self.active) {
            self.rebuildOverlay()
        }
    }

    fn rebuildOverlay() void {
        self.overlay = TerminalGrid.init(INSPECTOR_ROWS, self.overlay_cols)

        // Dark gray background for all cells
        for row in 0..INSPECTOR_ROWS {
            for col in 0..self.overlay_cols {
                const c = self.overlay.getCell(row, col)
                c.bg_r = 30
                c.bg_g = 30
                c.bg_b = 30
            }
        }

        // Row 0: separator line
        self.writeOverlayStr(0, 0, "─────────────────────────────────────────────", 120, 120, 120)

        // Row 1: header
        self.writeOverlayStr(1, 1, "Key Inspector", 255, 200, 50)
        self.writeOverlayStr(1, 20, "Key", 255, 200, 50)
        self.writeOverlayStr(1, 32, "Mods", 255, 200, 50)
        self.writeOverlayStr(1, 40, "PTY Bytes", 255, 200, 50)

        // Rows 2..11: events (most recent at top)
        var i: i64 = 0
        while (i < self.events.count and i < INSPECTOR_MAX_EVENTS) {
            const event_idx = self.events.count - 1 - i
            const rec = self.events.get(event_idx)
            const display_row = i + 2

            // Key name column (col 1)
            var key_name = keyName(rec.key)
            self.writeOverlayStr(display_row, 1, key_name, 220, 220, 220)

            // Key name again in column 20
            self.writeOverlayStr(display_row, 20, key_name, 220, 220, 220)

            // Mods column (col 32)
            var mods_str = modsString(rec.mods)
            self.writeOverlayStr(display_row, 32, mods_str, 150, 150, 150)

            // PTY bytes column (col 40)
            var bytes_str = bytesHex(rec.pty_bytes)
            self.writeOverlayStr(display_row, 40, bytes_str, 100, 220, 100)

            i += 1
        }
    }

    fn writeOverlayStr(row: i64, col: i64, s: string, r: i64, g: i64, b: i64) void {
        var i: i64 = 0
        while (i < @lenOf(s) and col + i < self.overlay_cols) {
            const c = self.overlay.getCell(row, col + i)
            c.codepoint = @intToPtr(*u8, @ptrOf(s) + i).*
            c.fg_r = r
            c.fg_g = g
            c.fg_b = b
            c.bg_r = 30
            c.bg_g = 30
            c.bg_b = 30
            i += 1
        }
    }
}

// ============================================================================
// Formatting helpers
// ============================================================================

fn keyName(key: i64) string {
    return switch (key) {
        KEY_TAB => "Tab",
        KEY_ENTER => "Enter",
        KEY_ESCAPE => "Esc",
        KEY_BACKSPACE => "Bksp",
        KEY_DELETE => "Del",
        KEY_ARROW_UP => "Up",
        KEY_ARROW_DOWN => "Down",
        KEY_ARROW_LEFT => "Left",
        KEY_ARROW_RIGHT => "Right",
        KEY_HOME => "Home",
        KEY_END => "End",
        KEY_PAGE_UP => "PgUp",
        KEY_PAGE_DOWN => "PgDn",
        KEY_F1 => "F1",
        KEY_F2 => "F2",
        KEY_F3 => "F3",
        KEY_F4 => "F4",
        KEY_F5 => "F5",
        KEY_F6 => "F6",
        KEY_F7 => "F7",
        KEY_F8 => "F8",
        KEY_F9 => "F9",
        KEY_F10 => "F10",
        KEY_F11 => "F11",
        KEY_F12 => "F12",
        ' ' => "Space",
        else => {
            // Printable ASCII
            if (key >= 33 and key <= 126) {
                var sb: StringBuilder = .{}
                sb.appendByte('\'')
                sb.appendByte(key)
                sb.appendByte('\'')
                return sb.toString()
            }
            // Unknown key — show as number
            var sb: StringBuilder = .{}
            sb.append("key:")
            sb.appendInt(key)
            return sb.toString()
        },
    }
}

fn modsString(mods: i64) string {
    if (mods == 0) { return "-" }
    var sb: StringBuilder = .{}
    var first: bool = true
    if ((mods & MOD_CTRL) != 0) {
        if (!first) { sb.appendByte('+') }
        sb.appendByte('C')
        first = false
    }
    if ((mods & MOD_SHIFT) != 0) {
        if (!first) { sb.appendByte('+') }
        sb.appendByte('S')
        first = false
    }
    if ((mods & MOD_ALT) != 0) {
        if (!first) { sb.appendByte('+') }
        sb.appendByte('A')
        first = false
    }
    if ((mods & MOD_SUPER) != 0) {
        if (!first) { sb.appendByte('+') }
        sb.appendByte('M')
        first = false
    }
    return sb.toString()
}

fn bytesHex(bytes: List(i64)) string {
    if (bytes.count == 0) { return "(none)" }
    var sb: StringBuilder = .{}
    var i: i64 = 0
    while (i < bytes.count) {
        if (i > 0) { sb.appendByte(' ') }
        const b = bytes.get(i)
        if (b == 0x1b) {
            sb.append("ESC")
        } else if (b < 32) {
            // Control chars: ^@ through ^_
            sb.appendByte('^')
            sb.appendByte(b + 64)
        } else if (b >= 32 and b <= 126) {
            sb.appendByte(b)
        } else {
            // Non-printable: show hex
            sb.append("0x")
            var hi = b / 16
            var lo = b % 16
            if (hi < 10) { sb.appendByte('0' + hi) } else { sb.appendByte('a' + hi - 10) }
            if (lo < 10) { sb.appendByte('0' + lo) } else { sb.appendByte('a' + lo - 10) }
        }
        i += 1
    }
    return sb.toString()
}
