/// Terminal cell: a single character with foreground/background colors and flags.

struct Cell {
    codepoint: i64,
    fg_r: i64,
    fg_g: i64,
    fg_b: i64,
    bg_r: i64,
    bg_g: i64,
    bg_b: i64,
    flags: i64,
}

/// Cell flags
const CELL_BOLD: i64 = 1
const CELL_UNDERLINE: i64 = 2
const CELL_INVERSE: i64 = 4
const CELL_SELECTED: i64 = 8

impl Cell {
    /// Create an empty cell with default colors (white on black).
    static fn init() Cell {
        return Cell {
            codepoint: 0,
            fg_r: 248, fg_g: 248, fg_b: 242,
            bg_r: 39, bg_g: 40, bg_b: 34,
            flags: 0,
        }
    }

    /// Create a cell with the given codepoint and default colors.
    static fn initChar(cp: i64) Cell {
        return Cell {
            codepoint: cp,
            fg_r: 248, fg_g: 248, fg_b: 242,
            bg_r: 39, bg_g: 40, bg_b: 34,
            flags: 0,
        }
    }

    /// Return true if this cell has no visible content.
    fn isBlank() bool {
        return self.codepoint == 0 or self.codepoint == ' '
    }
}

// ============================================================================
// Tests
// ============================================================================

test "cell init is blank" {
    var c = Cell.init()
    @assert(c.isBlank())
    @assertEq(c.codepoint, 0)
    @assertEq(c.flags, 0)
}

test "cell initChar stores codepoint" {
    var c = Cell.initChar('A')
    @assertEq(c.codepoint, 'A')
    @assert(!c.isBlank())
}

test "cell default fg color" {
    var c = Cell.init()
    @assertEq(c.fg_r, 248)
    @assertEq(c.fg_g, 248)
    @assertEq(c.fg_b, 242)
}

test "cell default bg color" {
    var c = Cell.init()
    @assertEq(c.bg_r, 39)
    @assertEq(c.bg_g, 40)
    @assertEq(c.bg_b, 34)
}

test "cell space is blank" {
    var c = Cell.initChar(' ')
    @assert(c.isBlank())
}

test "cell flags" {
    var c = Cell.init()
    c.flags = CELL_BOLD | CELL_UNDERLINE
    @assertEq(c.flags, 3)
}
