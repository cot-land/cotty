/// VT100/ANSI escape sequence parser.
/// Modeled on Ghostty's Parser.zig and stream.zig.

import "std/list"
import "std/string"
import "terminal"
import "cell"

// ============================================================================
// Parser States
// ============================================================================

const VT_GROUND: i64 = 0
const VT_ESCAPE: i64 = 1
const VT_CSI_PARAM: i64 = 2
const VT_OSC_STRING: i64 = 3

const MAX_PARAMS: i64 = 16

// ============================================================================
// ANSI Color Palette
// ============================================================================

/// Map a basic ANSI color index (0-15) to an RGB tuple.
fn basicColor(idx: i64) (i64, i64, i64) {
    if (idx == 0) { return (0, 0, 0) }
    if (idx == 1) { return (205, 0, 0) }
    if (idx == 2) { return (0, 205, 0) }
    if (idx == 3) { return (205, 205, 0) }
    if (idx == 4) { return (0, 0, 238) }
    if (idx == 5) { return (205, 0, 205) }
    if (idx == 6) { return (0, 205, 205) }
    if (idx == 7) { return (229, 229, 229) }
    if (idx == 8) { return (127, 127, 127) }
    if (idx == 9) { return (255, 0, 0) }
    if (idx == 10) { return (0, 255, 0) }
    if (idx == 11) { return (255, 255, 0) }
    if (idx == 12) { return (92, 92, 255) }
    if (idx == 13) { return (255, 0, 255) }
    if (idx == 14) { return (0, 255, 255) }
    return (255, 255, 255)
}

/// Convert a 6x6x6 cube level (0-5) to an 8-bit color value.
fn cubeLevel(level: i64) i64 {
    if (level == 0) { return 0 }
    return 55 + level * 40
}

/// Map a 256-color palette index to an RGB tuple.
fn colorFromIndex(idx: i64) (i64, i64, i64) {
    if (idx < 16) {
        return basicColor(idx)
    }
    if (idx < 232) {
        const ci = idx - 16
        return (cubeLevel(ci / 36), cubeLevel((ci / 6) % 6), cubeLevel(ci % 6))
    }
    const gray = (idx - 232) * 10 + 8
    return (gray, gray, gray)
}

// ============================================================================
// VtParser
// ============================================================================

/// State machine parser for VT100/ANSI escape sequences.
/// Feed bytes one at a time via feed(), or use feedBytes()/feedEsc() helpers.
struct VtParser {
    state: i64,
    params: List(i64),
    current_param: i64,
    has_param: bool,
    intermediate: i64,
}

impl VtParser {
    /// Create a parser in the ground state.
    static fn init() VtParser {
        var params: List(i64) = undefined
        params.items = 0
        params.count = 0
        params.capacity = 0

        return VtParser {
            state: VT_GROUND,
            params: params,
            current_param: 0,
            has_param: false,
            intermediate: 0,
        }
    }

    // -- Public API ---------------------------------------------------------

    /// Process a single byte through the state machine.
    fn feed(terminal: *TerminalState, b: i64) void {
        // ESC always transitions to escape state
        if (b == 0x1B) {
            self.state = VT_ESCAPE
            return
        }

        if (self.state == VT_GROUND) {
            if (b >= 0x20 and b < 0x7F) {
                terminal.putChar(b)
            } else if (b < 0x20) {
                self.executeC0(terminal, b)
            }
        } else if (self.state == VT_ESCAPE) {
            self.feedEscapeState(terminal, b)
        } else if (self.state == VT_CSI_PARAM) {
            self.feedCsiParam(terminal, b)
        } else if (self.state == VT_OSC_STRING) {
            if (b == 0x07) {
                self.state = VT_GROUND
            }
        }
    }

    /// Feed each byte of a string through the parser.
    fn feedBytes(terminal: *TerminalState, data: string) void {
        var i: i64 = 0
        while (i < @lenOf(data)) {
            self.feed(terminal, charAt(data, i))
            i += 1
        }
    }

    /// Feed an ESC-prefixed sequence (sends 0x1B then each byte of data).
    fn feedEsc(terminal: *TerminalState, data: string) void {
        self.feed(terminal, 0x1B)
        self.feedBytes(terminal, data)
    }

    // -- C0 controls --------------------------------------------------------

    /// Execute a C0 control character (0x00-0x1F, excluding ESC).
    fn executeC0(terminal: *TerminalState, b: i64) void {
        if (b == 0x0D) {
            terminal.carriageReturn()
        } else if (b == 0x0A or b == 0x0B or b == 0x0C) {
            terminal.newline()
        } else if (b == 0x08) {
            terminal.backspace()
        } else if (b == 0x09) {
            terminal.tab()
        }
    }

    // -- ESC state ----------------------------------------------------------

    /// Handle a byte in the VT_ESCAPE state.
    fn feedEscapeState(terminal: *TerminalState, b: i64) void {
        if (b < 0x20) {
            self.executeC0(terminal, b)
            return
        }

        if (b == '[') {
            self.state = VT_CSI_PARAM
            self.resetParams()
        } else if (b == ']') {
            self.state = VT_OSC_STRING
        } else if (b == 'D') {
            terminal.index_()
            self.state = VT_GROUND
        } else if (b == 'M') {
            terminal.reverseIndex()
            self.state = VT_GROUND
        } else if (b == '7') {
            terminal.saveCursor()
            self.state = VT_GROUND
        } else if (b == '8') {
            terminal.restoreCursor()
            self.state = VT_GROUND
        } else if (b == 'c') {
            terminal.grid.clear()
            terminal.setCursorPos(0, 0)
            terminal.resetAttributes()
            terminal.scroll_top = 0
            terminal.scroll_bottom = terminal.grid.rows - 1
            terminal.pending_wrap = false
            self.state = VT_GROUND
        } else if (b == '\\') {
            // ST — String Terminator (ends OSC/DCS)
            self.state = VT_GROUND
        } else {
            self.state = VT_GROUND
        }
    }

    // -- CSI param state ----------------------------------------------------

    /// Handle a byte in the VT_CSI_PARAM state.
    fn feedCsiParam(terminal: *TerminalState, b: i64) void {
        if (b >= '0' and b <= '9') {
            self.current_param = self.current_param * 10 + (b - '0')
            self.has_param = true
        } else if (b == ';') {
            self.pushParam()
        } else if (b == '?') {
            self.intermediate = b
        } else if (b >= 0x40 and b <= 0x7E) {
            if (self.has_param or self.params.count > 0) {
                self.pushParam()
            }
            self.dispatchCsi(terminal, b)
            self.resetParams()
            self.state = VT_GROUND
        } else if (b < 0x20) {
            self.executeC0(terminal, b)
        } else {
            self.resetParams()
            self.state = VT_GROUND
        }
    }

    // -- CSI dispatch -------------------------------------------------------

    /// Dispatch a complete CSI sequence based on the final byte.
    fn dispatchCsi(terminal: *TerminalState, ch: i64) void {
        if (ch == 'A') {
            terminal.cursorUp(self.param(0, 1))
        } else if (ch == 'B') {
            terminal.cursorDown(self.param(0, 1))
        } else if (ch == 'C') {
            terminal.cursorRight(self.param(0, 1))
        } else if (ch == 'D') {
            terminal.cursorLeft(self.param(0, 1))
        } else if (ch == 'H' or ch == 'f') {
            // CUP — 1-indexed params, convert to 0-indexed
            terminal.setCursorPos(self.param(0, 1) - 1, self.param(1, 1) - 1)
        } else if (ch == 'G') {
            // CHA — Cursor Horizontal Absolute (1-indexed)
            terminal.setCursorPos(terminal.cursor_row, self.param(0, 1) - 1)
        } else if (ch == 'd') {
            // VPA — Vertical Position Absolute (1-indexed)
            terminal.setCursorPos(self.param(0, 1) - 1, terminal.cursor_col)
        } else if (ch == 'J') {
            terminal.eraseInDisplay(self.rawParam(0, 0))
        } else if (ch == 'K') {
            terminal.eraseInLine(self.rawParam(0, 0))
        } else if (ch == 'L') {
            terminal.grid.insertLines(terminal.cursor_row, self.param(0, 1), terminal.scroll_bottom)
        } else if (ch == 'M') {
            terminal.grid.deleteLines(terminal.cursor_row, self.param(0, 1), terminal.scroll_bottom)
        } else if (ch == '@') {
            terminal.insertBlanks(self.param(0, 1))
        } else if (ch == 'P') {
            terminal.deleteChars(self.param(0, 1))
        } else if (ch == 'm') {
            self.dispatchSgr(terminal)
        } else if (ch == 'r') {
            // DECSTBM — 1-indexed params, convert to 0-indexed
            const top = self.param(0, 1) - 1
            const bottom = self.param(1, terminal.grid.rows) - 1
            terminal.setScrollingRegion(top, bottom)
        } else if (ch == 'h' or ch == 'l') {
            self.dispatchMode(terminal, ch == 'h')
        }
    }

    // -- SGR dispatch -------------------------------------------------------

    /// Parse and apply SGR (Select Graphic Rendition) parameters.
    fn dispatchSgr(terminal: *TerminalState) void {
        if (self.params.count == 0) {
            terminal.resetAttributes()
            return
        }

        var i: i64 = 0
        while (i < self.params.count) {
            const p = self.params.get(i)

            if (p == 0) {
                terminal.resetAttributes()
            } else if (p == 1) {
                terminal.bold = true
            } else if (p == 22) {
                terminal.bold = false
            } else if (p >= 30 and p <= 37) {
                const r, g, b = basicColor(p - 30)
                terminal.fg_r = r
                terminal.fg_g = g
                terminal.fg_b = b
            } else if (p == 38) {
                self.applySgrExtendedColor(terminal, i, true)
                i = self.skipExtendedColor(i)
            } else if (p == 39) {
                terminal.fg_r = DEFAULT_FG_R
                terminal.fg_g = DEFAULT_FG_G
                terminal.fg_b = DEFAULT_FG_B
            } else if (p >= 40 and p <= 47) {
                const r, g, b = basicColor(p - 40)
                terminal.bg_r = r
                terminal.bg_g = g
                terminal.bg_b = b
            } else if (p == 48) {
                self.applySgrExtendedColor(terminal, i, false)
                i = self.skipExtendedColor(i)
            } else if (p == 49) {
                terminal.bg_r = DEFAULT_BG_R
                terminal.bg_g = DEFAULT_BG_G
                terminal.bg_b = DEFAULT_BG_B
            } else if (p >= 90 and p <= 97) {
                const r, g, b = basicColor(p - 90 + 8)
                terminal.fg_r = r
                terminal.fg_g = g
                terminal.fg_b = b
            } else if (p >= 100 and p <= 107) {
                const r, g, b = basicColor(p - 100 + 8)
                terminal.bg_r = r
                terminal.bg_g = g
                terminal.bg_b = b
            }

            i += 1
        }
    }

    /// Apply a 256-color or truecolor extended color (38;5;N or 38;2;R;G;B).
    fn applySgrExtendedColor(terminal: *TerminalState, base: i64, is_fg: bool) void {
        if (base + 1 >= self.params.count) { return }
        const mode = self.params.get(base + 1)

        if (mode == 5 and base + 2 < self.params.count) {
            const r, g, b = colorFromIndex(self.params.get(base + 2))
            if (is_fg) {
                terminal.fg_r = r
                terminal.fg_g = g
                terminal.fg_b = b
            } else {
                terminal.bg_r = r
                terminal.bg_g = g
                terminal.bg_b = b
            }
        } else if (mode == 2 and base + 4 < self.params.count) {
            if (is_fg) {
                terminal.fg_r = self.params.get(base + 2)
                terminal.fg_g = self.params.get(base + 3)
                terminal.fg_b = self.params.get(base + 4)
            } else {
                terminal.bg_r = self.params.get(base + 2)
                terminal.bg_g = self.params.get(base + 3)
                terminal.bg_b = self.params.get(base + 4)
            }
        }
    }

    /// Return the last param index consumed by an extended color sequence.
    fn skipExtendedColor(base: i64) i64 {
        if (base + 1 >= self.params.count) { return base }
        const mode = self.params.get(base + 1)
        if (mode == 5) { return base + 2 }
        if (mode == 2) { return base + 4 }
        return base
    }

    // -- Mode dispatch (CSI ? h/l) ------------------------------------------

    /// Handle set/reset mode. Only DEC private modes (? prefix) for now.
    fn dispatchMode(terminal: *TerminalState, enable: bool) void {
        if (self.intermediate != '?') { return }
        // Mode handling is a no-op until cursor visibility / alt screen
        // are implemented. The parser correctly consumes the sequence.
    }

    // -- Parameter helpers --------------------------------------------------

    /// Save current_param into the params list and reset accumulator.
    fn pushParam() void {
        if (self.params.count < MAX_PARAMS) {
            self.params.append(self.current_param)
        }
        self.current_param = 0
        self.has_param = false
    }

    /// Clear all parameter state for the next sequence.
    fn resetParams() void {
        self.params.count = 0
        self.current_param = 0
        self.has_param = false
        self.intermediate = 0
    }

    /// Get parameter at idx, treating 0 as default (for cursor commands).
    fn param(idx: i64, default_val: i64) i64 {
        if (idx >= self.params.count) { return default_val }
        const val = self.params.get(idx)
        if (val == 0) { return default_val }
        return val
    }

    /// Get raw parameter at idx without 0-to-default substitution.
    fn rawParam(idx: i64, default_val: i64) i64 {
        if (idx >= self.params.count) { return default_val }
        return self.params.get(idx)
    }
}

// ============================================================================
// Tests — Color helpers
// ============================================================================

test "basicColor red" {
    const r, g, b = basicColor(1)
    @assertEq(r, 205)
    @assertEq(g, 0)
    @assertEq(b, 0)
}

test "colorFromIndex 256-color cube" {
    // Index 196 = cube(5, 0, 0) = (255, 0, 0)
    const r, g, b = colorFromIndex(196)
    @assertEq(r, 255)
    @assertEq(g, 0)
    @assertEq(b, 0)
}

test "colorFromIndex grayscale" {
    // Index 240 = gray level 8 = (88, 88, 88)
    const r, g, b = colorFromIndex(240)
    @assertEq(r, 88)
    @assertEq(g, 88)
    @assertEq(b, 88)
}

// ============================================================================
// Tests — Printable text and C0 controls
// ============================================================================

test "feed printable text" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedBytes(t, "Hello")
    @assertEq(t.grid.getCell(0, 0).codepoint, 'H')
    @assertEq(t.grid.getCell(0, 4).codepoint, 'o')
    @assertEq(t.cursor_col, 5)
}

test "feed CR LF" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feed(t, 'A')
    p.feed(t, 0x0D)
    p.feed(t, 0x0A)
    p.feed(t, 'B')
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(1, 0).codepoint, 'B')
}

test "feed backspace" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedBytes(t, "AB")
    p.feed(t, 0x08)
    @assertEq(t.cursor_col, 1)
}

test "feed tab" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feed(t, 0x09)
    @assertEq(t.cursor_col, 8)
}

// ============================================================================
// Tests — CSI cursor movement
// ============================================================================

test "CSI A cursor up" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    t.setCursorPos(5, 0)
    p.feedEsc(t, "[3A")
    @assertEq(t.cursor_row, 2)
}

test "CSI B cursor down" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedEsc(t, "[10B")
    @assertEq(t.cursor_row, 10)
}

test "CSI C cursor right" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedEsc(t, "[15C")
    @assertEq(t.cursor_col, 15)
}

test "CSI D cursor left" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    t.setCursorPos(0, 20)
    p.feedEsc(t, "[5D")
    @assertEq(t.cursor_col, 15)
}

test "CSI H cursor position" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // CSI 5;10 H → row 5, col 10 (1-indexed → 4, 9 in 0-indexed)
    p.feedEsc(t, "[5;10H")
    @assertEq(t.cursor_row, 4)
    @assertEq(t.cursor_col, 9)
}

test "CSI H defaults to 1;1" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    t.setCursorPos(10, 20)
    p.feedEsc(t, "[H")
    @assertEq(t.cursor_row, 0)
    @assertEq(t.cursor_col, 0)
}

// ============================================================================
// Tests — CSI erase
// ============================================================================

test "CSI J erase display all" {
    var p = VtParser.init()
    var t = TerminalState.init(3, 4)
    p.feedBytes(t, "AB")
    p.feedEsc(t, "[2J")
    @assert(t.grid.getCell(0, 0).isBlank())
    @assert(t.grid.getCell(0, 1).isBlank())
}

test "CSI K erase line right" {
    var p = VtParser.init()
    var t = TerminalState.init(3, 4)
    p.feedBytes(t, "ABCD")
    t.setCursorPos(0, 2)
    p.feedEsc(t, "[K")
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(0, 1).codepoint, 'B')
    @assert(t.grid.getCell(0, 2).isBlank())
    @assert(t.grid.getCell(0, 3).isBlank())
}

// ============================================================================
// Tests — CSI insert / delete
// ============================================================================

test "CSI @ insert blanks" {
    var p = VtParser.init()
    var t = TerminalState.init(3, 6)
    p.feedBytes(t, "ABCD")
    t.setCursorPos(0, 1)
    p.feedEsc(t, "[2@")
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assert(t.grid.getCell(0, 1).isBlank())
    @assert(t.grid.getCell(0, 2).isBlank())
    @assertEq(t.grid.getCell(0, 3).codepoint, 'B')
}

test "CSI P delete chars" {
    var p = VtParser.init()
    var t = TerminalState.init(3, 6)
    p.feedBytes(t, "ABCDEF")
    t.setCursorPos(0, 1)
    p.feedEsc(t, "[2P")
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(0, 1).codepoint, 'D')
    @assertEq(t.grid.getCell(0, 2).codepoint, 'E')
    @assertEq(t.grid.getCell(0, 3).codepoint, 'F')
}

// ============================================================================
// Tests — CSI scrolling region
// ============================================================================

test "CSI r set scrolling region" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedEsc(t, "[5;20r")
    @assertEq(t.scroll_top, 4)
    @assertEq(t.scroll_bottom, 19)
}

// ============================================================================
// Tests — SGR attributes
// ============================================================================

test "SGR reset (no params)" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    t.bold = true
    t.fg_r = 255
    p.feedEsc(t, "[m")
    @assertEq(t.bold, false)
    @assertEq(t.fg_r, DEFAULT_FG_R)
}

test "SGR bold" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedEsc(t, "[1m")
    @assertEq(t.bold, true)
    p.feedBytes(t, "X")
    @assertEq(t.grid.getCell(0, 0).flags & CELL_BOLD, CELL_BOLD)
}

test "SGR basic foreground color" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // SGR 31 = red foreground
    p.feedEsc(t, "[31m")
    @assertEq(t.fg_r, 205)
    @assertEq(t.fg_g, 0)
    @assertEq(t.fg_b, 0)
}

test "SGR basic background color" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // SGR 42 = green background
    p.feedEsc(t, "[42m")
    @assertEq(t.bg_r, 0)
    @assertEq(t.bg_g, 205)
    @assertEq(t.bg_b, 0)
}

test "SGR bright foreground" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // SGR 91 = bright red foreground
    p.feedEsc(t, "[91m")
    @assertEq(t.fg_r, 255)
    @assertEq(t.fg_g, 0)
    @assertEq(t.fg_b, 0)
}

test "SGR 256-color foreground" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // SGR 38;5;196 = 256-color red
    p.feedEsc(t, "[38;5;196m")
    @assertEq(t.fg_r, 255)
    @assertEq(t.fg_g, 0)
    @assertEq(t.fg_b, 0)
}

test "SGR truecolor foreground" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // SGR 38;2;100;150;200 = RGB foreground
    p.feedEsc(t, "[38;2;100;150;200m")
    @assertEq(t.fg_r, 100)
    @assertEq(t.fg_g, 150)
    @assertEq(t.fg_b, 200)
}

test "SGR truecolor background" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedEsc(t, "[48;2;10;20;30m")
    @assertEq(t.bg_r, 10)
    @assertEq(t.bg_g, 20)
    @assertEq(t.bg_b, 30)
}

test "SGR default foreground" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    t.fg_r = 255
    p.feedEsc(t, "[39m")
    @assertEq(t.fg_r, DEFAULT_FG_R)
}

test "SGR combined bold and color" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // SGR 1;31 = bold + red
    p.feedEsc(t, "[1;31m")
    @assertEq(t.bold, true)
    @assertEq(t.fg_r, 205)
    @assertEq(t.fg_g, 0)
}

// ============================================================================
// Tests — ESC sequences
// ============================================================================

test "ESC D index" {
    var p = VtParser.init()
    var t = TerminalState.init(3, 4)
    t.setCursorPos(1, 0)
    p.feedEsc(t, "D")
    @assertEq(t.cursor_row, 2)
}

test "ESC M reverse index" {
    var p = VtParser.init()
    var t = TerminalState.init(3, 4)
    t.grid.getCell(0, 0).codepoint = 'A'
    p.feedEsc(t, "M")
    @assertEq(t.cursor_row, 0)
    @assertEq(t.grid.getCell(1, 0).codepoint, 'A')
}

test "ESC 7/8 save restore cursor" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    t.setCursorPos(5, 10)
    p.feedEsc(t, "7")
    t.setCursorPos(0, 0)
    p.feedEsc(t, "8")
    @assertEq(t.cursor_row, 5)
    @assertEq(t.cursor_col, 10)
}

// ============================================================================
// Tests — Integration
// ============================================================================

test "mixed text and formatting" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // Write "Hi" in bold red, then reset
    p.feedEsc(t, "[1;31m")
    p.feedBytes(t, "Hi")
    p.feedEsc(t, "[0m")
    p.feedBytes(t, "!")
    @assertEq(t.grid.getCell(0, 0).codepoint, 'H')
    @assertEq(t.grid.getCell(0, 0).fg_r, 205)
    @assertEq(t.grid.getCell(0, 0).flags & CELL_BOLD, CELL_BOLD)
    @assertEq(t.grid.getCell(0, 2).codepoint, '!')
    @assertEq(t.grid.getCell(0, 2).fg_r, DEFAULT_FG_R)
    @assertEq(t.grid.getCell(0, 2).flags, 0)
}
