/// VT100/ANSI escape sequence parser.
/// Modeled on Ghostty's Parser.zig and stream.zig.

import "std/list"
import "std/string"
import "terminal"
import "cell"

// ============================================================================
// Parser States
// ============================================================================

const VT_GROUND: i64 = 0
const VT_ESCAPE: i64 = 1
const VT_CSI_PARAM: i64 = 2
const VT_OSC_STRING: i64 = 3
const VT_ESC_INTERMEDIATE: i64 = 4

const MAX_PARAMS: i64 = 16
const MAX_OSC_LEN: i64 = 4096

// ============================================================================
// ANSI Color Palette
// ============================================================================

/// Map a basic ANSI color index (0-15) to an RGB tuple from the given palette.
fn basicColor(idx: i64, palette: List(i64)) (i64, i64, i64) {
    var i = idx
    if (i < 0) { i = 0 }
    if (i > 15) { i = 15 }
    const base = i * 3
    return (palette.get(base), palette.get(base + 1), palette.get(base + 2))
}

/// Convert a 6x6x6 cube level (0-5) to an 8-bit color value.
fn cubeLevel(level: i64) i64 {
    if (level == 0) { return 0 }
    return 55 + level * 40
}

/// Map a 256-color palette index to an RGB tuple using the given palette.
fn colorFromIndex(idx: i64, palette: List(i64)) (i64, i64, i64) {
    if (idx < 16) {
        return basicColor(idx, palette)
    }
    if (idx < 232) {
        const ci = idx - 16
        return (cubeLevel(ci / 36), cubeLevel((ci / 6) % 6), cubeLevel(ci % 6))
    }
    const gray = (idx - 232) * 10 + 8
    return (gray, gray, gray)
}

// ============================================================================
// VtParser
// ============================================================================

/// State machine parser for VT100/ANSI escape sequences.
/// Feed bytes one at a time via feed(), or use feedBytes()/feedEsc() helpers.
struct VtParser {
    state: i64,
    params: List(i64),
    current_param: i64,
    has_param: bool,
    intermediate: i64,
    utf8_cp: i64,
    utf8_remaining: i64,
    esc_intermediate: i64,
    osc_buf: List(i64),
}

impl VtParser {
    /// Create a parser in the ground state.
    static fn init() VtParser {
        var params: List(i64) = undefined
        params.items = 0
        params.count = 0
        params.capacity = 0

        var osc: List(i64) = undefined
        osc.items = 0
        osc.count = 0
        osc.capacity = 0

        return VtParser {
            state: VT_GROUND,
            params: params,
            current_param: 0,
            has_param: false,
            intermediate: 0,
            utf8_cp: 0,
            utf8_remaining: 0,
            esc_intermediate: 0,
            osc_buf: osc,
        }
    }

    // -- Public API ---------------------------------------------------------

    /// Process a single byte through the state machine.
    fn feed(terminal: *TerminalState, b: i64) void {
        // ESC always transitions to escape state, aborts any UTF-8 sequence
        if (b == 0x1B) {
            // If we were in OSC, dispatch what we have (ESC \ is ST)
            if (self.state == VT_OSC_STRING) {
                self.dispatchOsc(terminal)
            }
            self.state = VT_ESCAPE
            self.utf8_remaining = 0
            return
        }

        if (self.state == VT_GROUND) {
            // UTF-8 continuation byte
            if (self.utf8_remaining > 0 and b >= 0x80 and b <= 0xBF) {
                self.utf8_cp = (self.utf8_cp << 6) | (b & 0x3F)
                self.utf8_remaining -= 1
                if (self.utf8_remaining == 0) {
                    terminal.putChar(self.utf8_cp)
                }
            } else if (b >= 0xC0 and b <= 0xF7) {
                // UTF-8 lead byte
                if (b < 0xE0) {
                    self.utf8_cp = b & 0x1F
                    self.utf8_remaining = 1
                } else if (b < 0xF0) {
                    self.utf8_cp = b & 0x0F
                    self.utf8_remaining = 2
                } else {
                    self.utf8_cp = b & 0x07
                    self.utf8_remaining = 3
                }
            } else if (b >= 0x20 and b < 0x7F) {
                terminal.putChar(b)
            } else if (b < 0x20) {
                self.executeC0(terminal, b)
            }
        } else if (self.state == VT_ESCAPE) {
            self.feedEscapeState(terminal, b)
        } else if (self.state == VT_CSI_PARAM) {
            self.feedCsiParam(terminal, b)
        } else if (self.state == VT_OSC_STRING) {
            if (b == 0x07) {
                self.dispatchOsc(terminal)
                self.state = VT_GROUND
            } else {
                if (self.osc_buf.count < MAX_OSC_LEN) {
                    self.osc_buf.append(b)
                }
            }
        } else if (self.state == VT_ESC_INTERMEDIATE) {
            self.feedEscIntermediate(terminal, b)
        }
    }

    /// Feed each byte of a string through the parser.
    fn feedBytes(terminal: *TerminalState, data: string) void {
        var i: i64 = 0
        while (i < @lenOf(data)) {
            self.feed(terminal, charAt(data, i))
            i += 1
        }
    }

    /// Feed an ESC-prefixed sequence (sends 0x1B then each byte of data).
    fn feedEsc(terminal: *TerminalState, data: string) void {
        self.feed(terminal, 0x1B)
        self.feedBytes(terminal, data)
    }

    // -- C0 controls --------------------------------------------------------

    /// Execute a C0 control character (0x00-0x1F, excluding ESC).
    fn executeC0(terminal: *TerminalState, b: i64) void {
        if (b == 0x07) {
            terminal.bell()
        } else if (b == 0x0D) {
            terminal.carriageReturn()
        } else if (b == 0x0A or b == 0x0B or b == 0x0C) {
            terminal.newline()
        } else if (b == 0x08) {
            terminal.backspace()
        } else if (b == 0x09) {
            terminal.tab()
        } else if (b == 0x0E) {
            // SO — Shift Out: activate G1 charset
            terminal.active_charset = 1
        } else if (b == 0x0F) {
            // SI — Shift In: activate G0 charset
            terminal.active_charset = 0
        }
    }

    // -- ESC state ----------------------------------------------------------

    /// Handle a byte in the VT_ESCAPE state.
    fn feedEscapeState(terminal: *TerminalState, b: i64) void {
        if (b < 0x20) {
            self.executeC0(terminal, b)
            return
        }

        if (b == '[') {
            self.state = VT_CSI_PARAM
            self.resetParams()
        } else if (b == ']') {
            self.state = VT_OSC_STRING
            self.osc_buf.count = 0
        } else if (b == '(' or b == ')' or b == '*' or b == '+') {
            // Charset designation: ESC ( / ) / * / + → intermediate
            self.esc_intermediate = b
            self.state = VT_ESC_INTERMEDIATE
        } else if (b == 'D') {
            terminal.index_()
            self.state = VT_GROUND
        } else if (b == 'H') {
            // HTS — Horizontal Tab Set
            terminal.tabSet()
            self.state = VT_GROUND
        } else if (b == 'M') {
            terminal.reverseIndex()
            self.state = VT_GROUND
        } else if (b == '7') {
            terminal.saveCursor()
            self.state = VT_GROUND
        } else if (b == '8') {
            terminal.restoreCursor()
            self.state = VT_GROUND
        } else if (b == 'c') {
            // RIS — Full Reset
            terminal.grid.clear()
            terminal.setCursorPos(0, 0)
            terminal.resetAttributes()
            terminal.scroll_top = 0
            terminal.scroll_bottom = terminal.grid.rows - 1
            terminal.pending_wrap = false
            terminal.cursor_visible = true
            terminal.mode_app_cursor = false
            terminal.mode_bracketed_paste = false
            terminal.mode_mouse_tracking = 0
            terminal.mode_mouse_format = 0
            terminal.mode_focus_events = false
            terminal.mode_sync_output = false
            terminal.mode_origin = false
            terminal.mode_wraparound = true
            terminal.mode_mouse_alt_scroll = true
            terminal.charset_g0 = 0
            terminal.charset_g1 = 0
            terminal.active_charset = 0
            terminal.cursor_shape = 0
            terminal.resetTabstops()
            if (terminal.mode_alt_screen) {
                terminal.leaveAltScreen()
            }
            self.state = VT_GROUND
        } else if (b == '\\') {
            // ST — String Terminator (ends OSC/DCS)
            self.state = VT_GROUND
        } else {
            self.state = VT_GROUND
        }
    }

    /// Handle final byte of a charset designation sequence (ESC ( / ) / * / + final).
    fn feedEscIntermediate(terminal: *TerminalState, b: i64) void {
        var charset: i64 = 0
        if (b == '0') {
            charset = 1  // DEC Special Graphics
        }
        // b == 'B' → ASCII (charset = 0, the default)

        if (self.esc_intermediate == '(') {
            terminal.charset_g0 = charset
        } else if (self.esc_intermediate == ')') {
            terminal.charset_g1 = charset
        }
        // G2/G3 (* / +) could be added but are rarely used

        self.state = VT_GROUND
    }

    // -- CSI param state ----------------------------------------------------

    /// Handle a byte in the VT_CSI_PARAM state.
    fn feedCsiParam(terminal: *TerminalState, b: i64) void {
        if (b >= '0' and b <= '9') {
            self.current_param = self.current_param * 10 + (b - '0')
            self.has_param = true
        } else if (b == ';') {
            self.pushParam()
        } else if (b == '?' or b == '>' or b == '<' or b == '=' or b == ' ' or b == '!') {
            self.intermediate = b
        } else if (b >= 0x40 and b <= 0x7E) {
            if (self.has_param or self.params.count > 0) {
                self.pushParam()
            }
            self.dispatchCsi(terminal, b)
            self.resetParams()
            self.state = VT_GROUND
        } else if (b < 0x20) {
            self.executeC0(terminal, b)
        } else {
            self.resetParams()
            self.state = VT_GROUND
        }
    }

    // -- CSI dispatch -------------------------------------------------------

    /// Dispatch a complete CSI sequence based on the final byte.
    fn dispatchCsi(terminal: *TerminalState, ch: i64) void {
        if (ch == 'A') {
            terminal.cursorUp(self.param(0, 1))
        } else if (ch == 'B') {
            terminal.cursorDown(self.param(0, 1))
        } else if (ch == 'C') {
            terminal.cursorRight(self.param(0, 1))
        } else if (ch == 'D') {
            terminal.cursorLeft(self.param(0, 1))
        } else if (ch == 'H' or ch == 'f') {
            // CUP — 1-indexed params, convert to 0-indexed
            terminal.setCursorPos(self.param(0, 1) - 1, self.param(1, 1) - 1)
        } else if (ch == 'G') {
            // CHA — Cursor Horizontal Absolute (1-indexed)
            terminal.setCursorPos(terminal.cursor_row, self.param(0, 1) - 1)
        } else if (ch == 'd') {
            // VPA — Vertical Position Absolute (1-indexed)
            terminal.setCursorPos(self.param(0, 1) - 1, terminal.cursor_col)
        } else if (ch == 'J') {
            terminal.eraseInDisplay(self.rawParam(0, 0))
        } else if (ch == 'K') {
            terminal.eraseInLine(self.rawParam(0, 0))
        } else if (ch == 'L') {
            terminal.grid.insertLines(terminal.cursor_row, self.param(0, 1), terminal.scroll_bottom)
        } else if (ch == 'M') {
            terminal.grid.deleteLines(terminal.cursor_row, self.param(0, 1), terminal.scroll_bottom)
        } else if (ch == '@') {
            terminal.insertBlanks(self.param(0, 1))
        } else if (ch == 'P') {
            terminal.deleteChars(self.param(0, 1))
        } else if (ch == 'm') {
            self.dispatchSgr(terminal)
        } else if (ch == 'r') {
            // DECSTBM — 1-indexed params, convert to 0-indexed
            const top = self.param(0, 1) - 1
            const bottom = self.param(1, terminal.grid.rows) - 1
            terminal.setScrollingRegion(top, bottom)
        } else if (ch == 'S') {
            // SU — Scroll Up
            var count = self.param(0, 1)
            while (count > 0) {
                terminal.grid.scrollUp(terminal.scroll_top, terminal.scroll_bottom)
                count -= 1
            }
        } else if (ch == 'T') {
            // SD — Scroll Down
            var count = self.param(0, 1)
            while (count > 0) {
                terminal.grid.scrollDown(terminal.scroll_top, terminal.scroll_bottom)
                count -= 1
            }
        } else if (ch == 'X') {
            // ECH — Erase Characters (erase N chars at cursor without moving)
            terminal.eraseChars(self.param(0, 1))
        } else if (ch == 'n') {
            // DSR — Device Status Report
            const dsrParam = self.param(0, 0)
            if (dsrParam == 5) {
                terminal.sendOperatingStatus()
            } else if (dsrParam == 6) {
                terminal.sendCursorPositionReport()
            }
        } else if (ch == 'c') {
            // DA — Device Attributes
            if (self.intermediate == '>') {
                terminal.sendSecondaryDeviceAttributes()
            } else if (self.intermediate == 0 or self.intermediate == '?') {
                terminal.sendPrimaryDeviceAttributes()
            }
        } else if (ch == 'g') {
            // TBC — Tab Clear
            terminal.tabClear(self.rawParam(0, 0))
        } else if (ch == 'I') {
            // CHT — Cursor Horizontal Forward Tabulation
            terminal.tabForward(self.param(0, 1))
        } else if (ch == 'Z') {
            // CBT — Cursor Backward Tabulation
            terminal.tabBackward(self.param(0, 1))
        } else if (ch == 'b') {
            // REP — Repeat preceding graphic character
            if (terminal.previous_char > 0) {
                var rep_count = self.param(0, 1)
                while (rep_count > 0) {
                    terminal.putChar(terminal.previous_char)
                    rep_count -= 1
                }
            }
        } else if (ch == 'q') {
            // DECSCUSR — Set Cursor Style (with space intermediate)
            if (self.intermediate == ' ') {
                terminal.cursor_shape = self.rawParam(0, 0)
            }
        } else if (ch == 'p') {
            // DECSTR — Soft Terminal Reset (with ! intermediate)
            if (self.intermediate == '!') {
                terminal.softReset()
            }
        } else if (ch == 'h' or ch == 'l') {
            self.dispatchMode(terminal, ch == 'h')
        }
    }

    // -- SGR dispatch -------------------------------------------------------

    /// Parse and apply SGR (Select Graphic Rendition) parameters.
    fn dispatchSgr(terminal: *TerminalState) void {
        if (self.params.count == 0) {
            terminal.resetAttributes()
            return
        }

        var i: i64 = 0
        while (i < self.params.count) {
            const p = self.params.get(i)

            if (p == 0) {
                terminal.resetAttributes()
            } else if (p == 1) {
                terminal.bold = true
            } else if (p == 2) {
                terminal.dim = true
            } else if (p == 3) {
                terminal.italic = true
            } else if (p == 4) {
                terminal.underline = true
            } else if (p == 7) {
                terminal.inverse = true
            } else if (p == 9) {
                terminal.strikethrough = true
            } else if (p == 22) {
                terminal.bold = false
                terminal.dim = false
            } else if (p == 23) {
                terminal.italic = false
            } else if (p == 24) {
                terminal.underline = false
            } else if (p == 27) {
                terminal.inverse = false
            } else if (p == 29) {
                terminal.strikethrough = false
            } else if (p >= 30 and p <= 37) {
                const r, g, b = basicColor(p - 30, terminal.palette)
                terminal.fg_r = r
                terminal.fg_g = g
                terminal.fg_b = b
            } else if (p == 38) {
                self.applySgrExtendedColor(terminal, i, true)
                i = self.skipExtendedColor(i)
            } else if (p == 39) {
                terminal.fg_r = terminal.default_fg_r
                terminal.fg_g = terminal.default_fg_g
                terminal.fg_b = terminal.default_fg_b
            } else if (p >= 40 and p <= 47) {
                const r, g, b = basicColor(p - 40, terminal.palette)
                terminal.bg_r = r
                terminal.bg_g = g
                terminal.bg_b = b
            } else if (p == 48) {
                self.applySgrExtendedColor(terminal, i, false)
                i = self.skipExtendedColor(i)
            } else if (p == 49) {
                terminal.bg_r = terminal.default_bg_r
                terminal.bg_g = terminal.default_bg_g
                terminal.bg_b = terminal.default_bg_b
            } else if (p >= 90 and p <= 97) {
                const r, g, b = basicColor(p - 90 + 8, terminal.palette)
                terminal.fg_r = r
                terminal.fg_g = g
                terminal.fg_b = b
            } else if (p >= 100 and p <= 107) {
                const r, g, b = basicColor(p - 100 + 8, terminal.palette)
                terminal.bg_r = r
                terminal.bg_g = g
                terminal.bg_b = b
            }

            i += 1
        }
    }

    /// Apply a 256-color or truecolor extended color (38;5;N or 38;2;R;G;B).
    fn applySgrExtendedColor(terminal: *TerminalState, base: i64, is_fg: bool) void {
        if (base + 1 >= self.params.count) { return }
        const mode = self.params.get(base + 1)

        if (mode == 5 and base + 2 < self.params.count) {
            const r, g, b = colorFromIndex(self.params.get(base + 2), terminal.palette)
            if (is_fg) {
                terminal.fg_r = r
                terminal.fg_g = g
                terminal.fg_b = b
            } else {
                terminal.bg_r = r
                terminal.bg_g = g
                terminal.bg_b = b
            }
        } else if (mode == 2 and base + 4 < self.params.count) {
            if (is_fg) {
                terminal.fg_r = self.params.get(base + 2)
                terminal.fg_g = self.params.get(base + 3)
                terminal.fg_b = self.params.get(base + 4)
            } else {
                terminal.bg_r = self.params.get(base + 2)
                terminal.bg_g = self.params.get(base + 3)
                terminal.bg_b = self.params.get(base + 4)
            }
        }
    }

    /// Return the last param index consumed by an extended color sequence.
    fn skipExtendedColor(base: i64) i64 {
        if (base + 1 >= self.params.count) { return base }
        const mode = self.params.get(base + 1)
        if (mode == 5) { return base + 2 }
        if (mode == 2) { return base + 4 }
        return base
    }

    // -- Mode dispatch (CSI ? h/l) ------------------------------------------

    /// Handle set/reset mode. Only DEC private modes (? prefix) for now.
    fn dispatchMode(terminal: *TerminalState, enable: bool) void {
        if (self.intermediate != '?') { return }
        var i: i64 = 0
        while (i < self.params.count) {
            terminal.setDecMode(self.params.get(i), enable)
            i += 1
        }
    }

    // -- OSC dispatch -------------------------------------------------------

    /// Dispatch a complete OSC sequence from osc_buf.
    fn dispatchOsc(terminal: *TerminalState) void {
        if (self.osc_buf.count == 0) { return }

        // Parse numeric command before first ';'
        var cmd: i64 = 0
        var i: i64 = 0
        while (i < self.osc_buf.count) {
            const ch = self.osc_buf.get(i)
            if (ch == ';') {
                i += 1
                break
            }
            if (ch >= '0' and ch <= '9') {
                cmd = cmd * 10 + (ch - '0')
            }
            i += 1
        }

        // i now points to payload start
        const payload_start = i
        const payload_len = self.osc_buf.count - payload_start

        if (cmd == 0 or cmd == 2) {
            terminal.setTitle(self.osc_buf, payload_start, payload_len)
        } else if (cmd == 7) {
            terminal.setPwd(self.osc_buf, payload_start, payload_len)
        }
    }

    // -- Parameter helpers --------------------------------------------------

    /// Save current_param into the params list and reset accumulator.
    fn pushParam() void {
        if (self.params.count < MAX_PARAMS) {
            self.params.append(self.current_param)
        }
        self.current_param = 0
        self.has_param = false
    }

    /// Clear all parameter state for the next sequence.
    fn resetParams() void {
        self.params.count = 0
        self.current_param = 0
        self.has_param = false
        self.intermediate = 0
    }

    /// Get parameter at idx, treating 0 as default (for cursor commands).
    fn param(idx: i64, default_val: i64) i64 {
        if (idx >= self.params.count) { return default_val }
        const val = self.params.get(idx)
        if (val == 0) { return default_val }
        return val
    }

    /// Get raw parameter at idx without 0-to-default substitution.
    fn rawParam(idx: i64, default_val: i64) i64 {
        if (idx >= self.params.count) { return default_val }
        return self.params.get(idx)
    }
}

// ============================================================================
// Tests — Color helpers
// ============================================================================

test "basicColor red" {
    var t = TerminalState.init(2, 2)
    const r, g, b = basicColor(1, t.palette)
    @assertEq(r, 244)
    @assertEq(g, 0)
    @assertEq(b, 95)
}

test "colorFromIndex 256-color cube" {
    var t = TerminalState.init(2, 2)
    // Index 196 = cube(5, 0, 0) = (255, 0, 0)
    const r, g, b = colorFromIndex(196, t.palette)
    @assertEq(r, 255)
    @assertEq(g, 0)
    @assertEq(b, 0)
}

test "colorFromIndex grayscale" {
    var t = TerminalState.init(2, 2)
    // Index 240 = gray level 8 = (88, 88, 88)
    const r, g, b = colorFromIndex(240, t.palette)
    @assertEq(r, 88)
    @assertEq(g, 88)
    @assertEq(b, 88)
}

// ============================================================================
// Tests — Printable text and C0 controls
// ============================================================================

test "feed printable text" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedBytes(t, "Hello")
    @assertEq(t.grid.getCell(0, 0).codepoint, 'H')
    @assertEq(t.grid.getCell(0, 4).codepoint, 'o')
    @assertEq(t.cursor_col, 5)
}

test "feed CR LF" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feed(t, 'A')
    p.feed(t, 0x0D)
    p.feed(t, 0x0A)
    p.feed(t, 'B')
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(1, 0).codepoint, 'B')
}

test "feed backspace" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedBytes(t, "AB")
    p.feed(t, 0x08)
    @assertEq(t.cursor_col, 1)
}

test "feed tab" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feed(t, 0x09)
    @assertEq(t.cursor_col, 8)
}

// ============================================================================
// Tests — CSI cursor movement
// ============================================================================

test "CSI A cursor up" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    t.setCursorPos(5, 0)
    p.feedEsc(t, "[3A")
    @assertEq(t.cursor_row, 2)
}

test "CSI B cursor down" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedEsc(t, "[10B")
    @assertEq(t.cursor_row, 10)
}

test "CSI C cursor right" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedEsc(t, "[15C")
    @assertEq(t.cursor_col, 15)
}

test "CSI D cursor left" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    t.setCursorPos(0, 20)
    p.feedEsc(t, "[5D")
    @assertEq(t.cursor_col, 15)
}

test "CSI H cursor position" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // CSI 5;10 H → row 5, col 10 (1-indexed → 4, 9 in 0-indexed)
    p.feedEsc(t, "[5;10H")
    @assertEq(t.cursor_row, 4)
    @assertEq(t.cursor_col, 9)
}

test "CSI H defaults to 1;1" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    t.setCursorPos(10, 20)
    p.feedEsc(t, "[H")
    @assertEq(t.cursor_row, 0)
    @assertEq(t.cursor_col, 0)
}

// ============================================================================
// Tests — CSI erase
// ============================================================================

test "CSI J erase display all" {
    var p = VtParser.init()
    var t = TerminalState.init(3, 4)
    p.feedBytes(t, "AB")
    p.feedEsc(t, "[2J")
    @assert(t.grid.getCell(0, 0).isBlank())
    @assert(t.grid.getCell(0, 1).isBlank())
}

test "CSI K erase line right" {
    var p = VtParser.init()
    var t = TerminalState.init(3, 4)
    p.feedBytes(t, "ABCD")
    t.setCursorPos(0, 2)
    p.feedEsc(t, "[K")
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(0, 1).codepoint, 'B')
    @assert(t.grid.getCell(0, 2).isBlank())
    @assert(t.grid.getCell(0, 3).isBlank())
}

// ============================================================================
// Tests — CSI insert / delete
// ============================================================================

test "CSI @ insert blanks" {
    var p = VtParser.init()
    var t = TerminalState.init(3, 6)
    p.feedBytes(t, "ABCD")
    t.setCursorPos(0, 1)
    p.feedEsc(t, "[2@")
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assert(t.grid.getCell(0, 1).isBlank())
    @assert(t.grid.getCell(0, 2).isBlank())
    @assertEq(t.grid.getCell(0, 3).codepoint, 'B')
}

test "CSI P delete chars" {
    var p = VtParser.init()
    var t = TerminalState.init(3, 6)
    p.feedBytes(t, "ABCDEF")
    t.setCursorPos(0, 1)
    p.feedEsc(t, "[2P")
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(0, 1).codepoint, 'D')
    @assertEq(t.grid.getCell(0, 2).codepoint, 'E')
    @assertEq(t.grid.getCell(0, 3).codepoint, 'F')
}

// ============================================================================
// Tests — CSI scrolling region
// ============================================================================

test "CSI r set scrolling region" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedEsc(t, "[5;20r")
    @assertEq(t.scroll_top, 4)
    @assertEq(t.scroll_bottom, 19)
}

// ============================================================================
// Tests — SGR attributes
// ============================================================================

test "SGR reset (no params)" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    t.bold = true
    t.fg_r = 255
    p.feedEsc(t, "[m")
    @assertEq(t.bold, false)
    @assertEq(t.fg_r, t.default_fg_r)
}

test "SGR bold" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedEsc(t, "[1m")
    @assertEq(t.bold, true)
    p.feedBytes(t, "X")
    @assertEq(t.grid.getCell(0, 0).flags & CELL_BOLD, CELL_BOLD)
}

test "SGR basic foreground color" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // SGR 31 = red foreground (Monokai Remastered: #f4005f)
    p.feedEsc(t, "[31m")
    @assertEq(t.fg_r, 244)
    @assertEq(t.fg_g, 0)
    @assertEq(t.fg_b, 95)
}

test "SGR basic background color" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // SGR 42 = green background (Monokai Remastered: #98e024)
    p.feedEsc(t, "[42m")
    @assertEq(t.bg_r, 152)
    @assertEq(t.bg_g, 224)
    @assertEq(t.bg_b, 36)
}

test "SGR bright foreground" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // SGR 91 = bright red foreground (Monokai Remastered: #f4005f)
    p.feedEsc(t, "[91m")
    @assertEq(t.fg_r, 244)
    @assertEq(t.fg_g, 0)
    @assertEq(t.fg_b, 95)
}

test "SGR 256-color foreground" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // SGR 38;5;196 = 256-color red
    p.feedEsc(t, "[38;5;196m")
    @assertEq(t.fg_r, 255)
    @assertEq(t.fg_g, 0)
    @assertEq(t.fg_b, 0)
}

test "SGR truecolor foreground" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // SGR 38;2;100;150;200 = RGB foreground
    p.feedEsc(t, "[38;2;100;150;200m")
    @assertEq(t.fg_r, 100)
    @assertEq(t.fg_g, 150)
    @assertEq(t.fg_b, 200)
}

test "SGR truecolor background" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    p.feedEsc(t, "[48;2;10;20;30m")
    @assertEq(t.bg_r, 10)
    @assertEq(t.bg_g, 20)
    @assertEq(t.bg_b, 30)
}

test "SGR default foreground" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    t.fg_r = 255
    p.feedEsc(t, "[39m")
    @assertEq(t.fg_r, t.default_fg_r)
}

test "SGR combined bold and color" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // SGR 1;31 = bold + red (Monokai Remastered: #f4005f)
    p.feedEsc(t, "[1;31m")
    @assertEq(t.bold, true)
    @assertEq(t.fg_r, 244)
    @assertEq(t.fg_g, 0)
}

// ============================================================================
// Tests — ESC sequences
// ============================================================================

test "ESC D index" {
    var p = VtParser.init()
    var t = TerminalState.init(3, 4)
    t.setCursorPos(1, 0)
    p.feedEsc(t, "D")
    @assertEq(t.cursor_row, 2)
}

test "ESC M reverse index" {
    var p = VtParser.init()
    var t = TerminalState.init(3, 4)
    t.grid.getCell(0, 0).codepoint = 'A'
    p.feedEsc(t, "M")
    @assertEq(t.cursor_row, 0)
    @assertEq(t.grid.getCell(1, 0).codepoint, 'A')
}

test "ESC 7/8 save restore cursor" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    t.setCursorPos(5, 10)
    p.feedEsc(t, "7")
    t.setCursorPos(0, 0)
    p.feedEsc(t, "8")
    @assertEq(t.cursor_row, 5)
    @assertEq(t.cursor_col, 10)
}

// ============================================================================
// Tests — Integration
// ============================================================================

test "mixed text and formatting" {
    var p = VtParser.init()
    var t = TerminalState.init(24, 80)
    // Write "Hi" in bold red, then reset
    p.feedEsc(t, "[1;31m")
    p.feedBytes(t, "Hi")
    p.feedEsc(t, "[0m")
    p.feedBytes(t, "!")
    @assertEq(t.grid.getCell(0, 0).codepoint, 'H')
    @assertEq(t.grid.getCell(0, 0).fg_r, 244)
    @assertEq(t.grid.getCell(0, 0).flags & CELL_BOLD, CELL_BOLD)
    @assertEq(t.grid.getCell(0, 2).codepoint, '!')
    @assertEq(t.grid.getCell(0, 2).fg_r, t.default_fg_r)
    @assertEq(t.grid.getCell(0, 2).flags, 0)
}
