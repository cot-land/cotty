/// Application state for Cotty.
/// Maps to Ghostty's App.zig — the top-level owner of all surfaces and state.

import "std/list"
import "std/sys"
import "std/string"
import "surface"
import "config"
import "message"

/// The core application state. Owns surfaces, config, and the message mailbox.
/// Surfaces are heap-allocated via `new` with ARC reference counting.
/// The list stores *Surface pointers — when the list grows, only pointer values
/// move (not the Surfaces), so IO thread raw pointers remain stable.
struct App {
    surfaces: List(*Surface),
    config: Config,
    focused_surface: ?*Surface,
    running: bool,
    mailbox: List(Message),

    /// Create and initialize the application with default config.
    static fn init() App {
        var surfaces: List(*Surface) = .{}
        var mailbox: List(Message) = .{}

        return App {
            surfaces: surfaces,
            config: Config.init(),
            focused_surface: null,
            running: true,
            mailbox: mailbox,
        }
    }

    /// Add a new empty surface. Returns its pointer (the opaque handle).
    fn addSurface() *Surface {
        const s = Surface.init()
        self.surfaces.append(s)
        if (self.focused_surface == null) {
            self.focused_surface = s
        }
        return s
    }

    /// Add a surface from a file path. Returns its pointer.
    fn addSurfaceFromFile(path: string) *Surface {
        const s = Surface.initFromFile(path)
        self.surfaces.append(s)
        self.focused_surface = s
        return s
    }

    /// Add a terminal surface with the given dimensions. Returns its pointer.
    fn addTerminalSurface(rows: i64, cols: i64) *Surface {
        const s = Surface.initTerminal(rows, cols)
        self.surfaces.append(s)
        self.focused_surface = s
        return s
    }

    /// Remove a surface by pointer. ARC releases the *Surface when removed.
    /// For terminal surfaces, the FFI shutdown path (cotty_terminal_surface_free)
    /// closes PTY, joins IO thread, and cleans up before calling this.
    fn removeSurface(ptr: *Surface) void {
        var i: i64 = 0
        while (i < self.surfaces.count) {
            if (@ptrToInt(self.surfaces.get(i)) == @ptrToInt(ptr)) {
                self.surfaces.orderedRemove(i)
                if (self.surfaces.count == 0) {
                    self.focused_surface = null
                } else if (self.focused_surface) |focus| {
                    if (@ptrToInt(focus) == @ptrToInt(ptr)) {
                        self.focused_surface = self.surfaces.get(self.surfaces.count - 1)
                    }
                }
                return
            }
            i += 1
        }
    }

    /// Post a message to the mailbox.
    fn postMessage(msg: Message) void {
        self.mailbox.append(msg)
    }

    /// Process all queued mailbox messages.
    fn drainMailbox() void {
        for i in 0..self.mailbox.count {
            const msg = self.mailbox.get(i)
            self.handleMessage(msg)
        }
        // Clear the mailbox
        self.mailbox.count = 0
    }

    /// Handle a single message.
    fn handleMessage(msg: Message) void {
        switch (msg) {
            Message.open_file |path| => {
                self.addSurfaceFromFile(path)
            },
            Message.close_surface |ptr_val| => {
                self.removeSurface(@intToPtr(*Surface, ptr_val))
            },
            Message.quit => {
                self.running = false
            },
            Message.save => {
                // Save handled by surface directly
            },
            Message.redraw => {
                // Redraw handled by render loop
            },
        }
    }

    /// Run one tick of the application loop.
    fn tick() void {
        self.drainMailbox()
    }

    /// Return the number of open surfaces.
    fn surfaceCount() int {
        return self.surfaces.count
    }
}

// ============================================================================
// Tests
// ============================================================================

test "app init" {
    var app = App.init()
    @assertEq(app.running, true)
    @assertEq(app.surfaceCount(), 0)
    @assert(app.focused_surface == null)
}

test "app add surface" {
    var app = App.init()
    const s = app.addSurface()
    @assertEq(app.surfaceCount(), 1)
    @assert(app.focused_surface != null)
    @assert(@ptrToInt(app.focused_surface.?) == @ptrToInt(s))
}

test "app add multiple surfaces" {
    var app = App.init()
    app.addSurface()
    app.addSurface()
    app.addSurface()
    @assertEq(app.surfaceCount(), 3)
}

test "app remove surface" {
    var app = App.init()
    const s1 = app.addSurface()
    app.addSurface()
    app.removeSurface(s1)
    @assertEq(app.surfaceCount(), 1)
}

test "app remove last surface clears focus" {
    var app = App.init()
    const s = app.addSurface()
    app.removeSurface(s)
    @assertEq(app.surfaceCount(), 0)
    @assert(app.focused_surface == null)
}

test "app post and drain message" {
    var app = App.init()
    app.addSurface()
    app.postMessage(Message.quit)
    @assertEq(app.running, true)
    app.drainMailbox()
    @assertEq(app.running, false)
}

test "app tick drains mailbox" {
    var app = App.init()
    app.postMessage(Message.quit)
    app.tick()
    @assertEq(app.running, false)
}

test "app open file message" {
    var app = App.init()
    app.postMessage(Message.open_file("test.cot"))
    app.drainMailbox()
    @assertEq(app.surfaceCount(), 1)
}

test "app close surface message" {
    var app = App.init()
    const s = app.addSurface()
    app.addSurface()
    app.postMessage(Message.close_surface(@ptrToInt(s)))
    app.drainMailbox()
    @assertEq(app.surfaceCount(), 1)
}

test "app config defaults" {
    var app = App.init()
    @assertEq(app.config.font_size, 18)
    @assertEq(app.config.padding, 8)
    @assertEq(app.config.bg_r, 12)
    @assertEq(app.config.fg_r, 217)
}
