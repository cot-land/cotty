/// Terminal grid and state: cell storage, cursor, scroll regions, SGR attributes.
/// Modeled on Ghostty's Terminal.zig and Screen.zig.

import "std/list"
import "std/sys"
import "cell"
import "config"
import "input"

// ============================================================================
// TerminalGrid — flat cell storage (rows * cols)
// ============================================================================

/// Flat grid of cells addressed by (row, col).
/// Cells are stored contiguously in row-major order.
/// row_wrap tracks soft-wrap state per row for resize reflow.
struct TerminalGrid {
    cells: List(Cell),
    rows: i64,
    cols: i64,
    row_wrap: List(i64),
    active_start: i64,
    max_scrollback: i64,
    scrollback_enabled: i64,
}

impl TerminalGrid {
    /// Create a grid of rows * cols blank cells with default colors.
    static fn init(rows: i64, cols: i64) TerminalGrid {
        var cells: List(Cell) = undefined
        cells.items = 0
        cells.count = 0
        cells.capacity = 0

        var i: i64 = 0
        const total = rows * cols
        while (i < total) {
            cells.append(Cell.init())
            i += 1
        }

        var wraps: List(i64) = undefined
        wraps.items = 0
        wraps.count = 0
        wraps.capacity = 0
        var w: i64 = 0
        while (w < rows) {
            wraps.append(0)
            w += 1
        }

        return TerminalGrid {
            cells: cells,
            rows: rows,
            cols: cols,
            row_wrap: wraps,
            active_start: 0,
            max_scrollback: 10000,
            scrollback_enabled: 1,
        }
    }

    /// Get a pointer to the cell at (row, col), offset by active_start.
    fn getCell(row: i64, col: i64) *Cell {
        const idx = (self.active_start + row) * self.cols + col
        return @intToPtr(*Cell, self.cells.items + idx * @sizeOf(Cell))
    }

    /// Get the wrap flag for a row (1 = soft-wrapped into next row).
    fn getRowWrap(row: i64) i64 {
        return @intToPtr(*i64, self.row_wrap.items + (self.active_start + row) * @sizeOf(i64)).*
    }

    /// Set the wrap flag for a row (1 = soft-wrapped, 0 = hard break).
    fn setRowWrap(row: i64, val: i64) void {
        @intToPtr(*i64, self.row_wrap.items + (self.active_start + row) * @sizeOf(i64)).* = val
    }

    /// Clear the entire grid to default blank cells.
    fn clear() void {
        var row: i64 = 0
        while (row < self.rows) {
            self.clearLine(row)
            row += 1
        }
    }

    /// Clear a single row to default blank cells and reset its wrap flag.
    fn clearLine(row: i64) void {
        var col: i64 = 0
        while (col < self.cols) {
            self.getCell(row, col).* = Cell.init()
            col += 1
        }
        self.setRowWrap(row, 0)
    }

    /// Scroll the region [top..bottom] up by one line.
    /// Full-screen scroll on primary screen: append blank row, increment active_start
    /// (old top row preserved as scrollback). Sub-region: memcpy within active area.
    fn scrollUp(top: i64, bottom: i64) void {
        // Full-screen scroll with scrollback enabled: no memcpy needed
        if (top == 0) {
            if (bottom == self.rows - 1) {
                if (self.scrollback_enabled == 1) {
                    // Append a blank row of cells
                    var i: i64 = 0
                    while (i < self.cols) {
                        self.cells.append(Cell.init())
                        i += 1
                    }
                    // Append a wrap flag for the new row
                    self.row_wrap.append(0)
                    // Advance active_start — old top row is now scrollback
                    self.active_start += 1
                    self.trimScrollback()
                    return
                }
            }
        }
        // Sub-region scroll: memcpy within active area
        var row = top
        while (row < bottom) {
            const dst = self.cells.items + ((self.active_start + row) * self.cols) * @sizeOf(Cell)
            const src = self.cells.items + ((self.active_start + row + 1) * self.cols) * @sizeOf(Cell)
            memcpy(dst, src, self.cols * @sizeOf(Cell))
            self.setRowWrap(row, self.getRowWrap(row + 1))
            row += 1
        }
        self.clearLine(bottom)
    }

    /// Scroll the region [top..bottom] down by one line.
    /// Content and wrap flags shift down, top line is cleared with defaults.
    fn scrollDown(top: i64, bottom: i64) void {
        var row = bottom
        while (row > top) {
            const dst = self.cells.items + ((self.active_start + row) * self.cols) * @sizeOf(Cell)
            const src = self.cells.items + ((self.active_start + row - 1) * self.cols) * @sizeOf(Cell)
            memcpy(dst, src, self.cols * @sizeOf(Cell))
            self.setRowWrap(row, self.getRowWrap(row - 1))
            row -= 1
        }
        self.clearLine(top)
    }

    /// Insert count blank lines at row, shifting content down within [row..bottom].
    fn insertLines(row: i64, count: i64, bottom: i64) void {
        var i: i64 = 0
        while (i < count) {
            self.scrollDown(row, bottom)
            i += 1
        }
    }

    /// Delete count lines at row, shifting content up within [row..bottom].
    fn deleteLines(row: i64, count: i64, bottom: i64) void {
        var i: i64 = 0
        while (i < count) {
            self.scrollUp(row, bottom)
            i += 1
        }
    }

    /// Trim scrollback when it exceeds max_scrollback rows.
    /// Moves remaining cells/wraps forward and adjusts active_start.
    fn trimScrollback() void {
        if (self.active_start <= self.max_scrollback) { return }
        const trim = self.active_start - self.max_scrollback
        const total_cells = (self.active_start + self.rows) * self.cols
        const keep_cells = total_cells - trim * self.cols
        // memmove cells forward
        memcpy(self.cells.items, self.cells.items + trim * self.cols * @sizeOf(Cell), keep_cells * @sizeOf(Cell))
        self.cells.count = keep_cells
        // memmove row_wrap forward
        const total_wraps = self.active_start + self.rows
        const keep_wraps = total_wraps - trim
        memcpy(self.row_wrap.items, self.row_wrap.items + trim * @sizeOf(i64), keep_wraps * @sizeOf(i64))
        self.row_wrap.count = keep_wraps
        self.active_start = self.max_scrollback
    }
}

// ============================================================================
// DEC Special Graphics charset mapping
// ============================================================================

/// Map a codepoint in the DEC Special Graphics range (0x60-0x7E) to its
/// Unicode box-drawing equivalent. From Ghostty's charsets.zig dec_special table.
fn decSpecialMap(cp: i64) i64 {
    if (cp == 0x60) { return 0x25C6 }  // ◆
    if (cp == 0x61) { return 0x2592 }  // ▒
    if (cp == 0x62) { return 0x2409 }  // HT
    if (cp == 0x63) { return 0x240C }  // FF
    if (cp == 0x64) { return 0x240D }  // CR
    if (cp == 0x65) { return 0x240A }  // LF
    if (cp == 0x66) { return 0x00B0 }  // °
    if (cp == 0x67) { return 0x00B1 }  // ±
    if (cp == 0x68) { return 0x2424 }  // NL
    if (cp == 0x69) { return 0x240B }  // VT
    if (cp == 0x6A) { return 0x2518 }  // ┘
    if (cp == 0x6B) { return 0x2510 }  // ┐
    if (cp == 0x6C) { return 0x250C }  // ┌
    if (cp == 0x6D) { return 0x2514 }  // └
    if (cp == 0x6E) { return 0x253C }  // ┼
    if (cp == 0x6F) { return 0x23BA }  // ⎺
    if (cp == 0x70) { return 0x23BB }  // ⎻
    if (cp == 0x71) { return 0x2500 }  // ─
    if (cp == 0x72) { return 0x23BC }  // ⎼
    if (cp == 0x73) { return 0x23BD }  // ⎽
    if (cp == 0x74) { return 0x251C }  // ├
    if (cp == 0x75) { return 0x2524 }  // ┤
    if (cp == 0x76) { return 0x2534 }  // ┴
    if (cp == 0x77) { return 0x252C }  // ┬
    if (cp == 0x78) { return 0x2502 }  // │
    if (cp == 0x79) { return 0x2264 }  // ≤
    if (cp == 0x7A) { return 0x2265 }  // ≥
    if (cp == 0x7B) { return 0x03C0 }  // π
    if (cp == 0x7C) { return 0x2260 }  // ≠
    if (cp == 0x7D) { return 0x00A3 }  // £
    if (cp == 0x7E) { return 0x00B7 }  // ·
    return cp
}

// ============================================================================
// Tabstop initialization
// ============================================================================

/// Create a tabstop list with stops set every 8 columns.
fn initTabstops(cols: i64) List(i64) {
    var stops: List(i64) = undefined
    stops.items = 0
    stops.count = 0
    stops.capacity = 0
    var i: i64 = 0
    while (i < cols) {
        if (i % 8 == 0) {
            stops.append(1)
        } else {
            stops.append(0)
        }
        i += 1
    }
    return stops
}

// ============================================================================
// TerminalState — cursor, attributes, scroll region, pending wrap
// ============================================================================

/// Full terminal state: grid + cursor + SGR attributes + scroll region.
/// Implements VT100/ANSI escape sequence semantics including deferred wrapping.
struct TerminalState {
    grid: TerminalGrid,
    cursor_row: i64,
    cursor_col: i64,
    saved_row: i64,
    saved_col: i64,
    pending_wrap: bool,
    fg_r: i64,
    fg_g: i64,
    fg_b: i64,
    bg_r: i64,
    bg_g: i64,
    bg_b: i64,
    bold: bool,
    dim: bool,
    italic: bool,
    underline: bool,
    inverse: bool,
    strikethrough: bool,
    default_fg_r: i64,
    default_fg_g: i64,
    default_fg_b: i64,
    default_bg_r: i64,
    default_bg_g: i64,
    default_bg_b: i64,
    palette: List(i64),
    scroll_top: i64,
    scroll_bottom: i64,
    pty_fd: i64,
    child_pid: i64,
    sel_active: bool,
    sel_start_row: i64,
    sel_start_col: i64,
    sel_end_row: i64,
    sel_end_col: i64,
    cursor_visible: bool,
    mode_alt_screen: bool,
    mode_app_cursor: bool,
    mode_bracketed_paste: bool,
    mode_mouse_tracking: i64,
    mode_mouse_format: i64,
    mode_focus_events: bool,
    mode_sync_output: bool,
    mode_origin: bool,
    mode_wraparound: bool,
    mode_mouse_alt_scroll: bool,
    charset_g0: i64,
    charset_g1: i64,
    active_charset: i64,
    tabstops: List(i64),
    cursor_shape: i64,
    previous_char: i64,
    title_buf: i64,
    title_len: i64,
    bell_pending: bool,
    alt_grid: TerminalGrid,
    alt_cursor_row: i64,
    alt_cursor_col: i64,
    alt_saved_row: i64,
    alt_saved_col: i64,
    scroll_accumulator: i64,
    viewport_row: i64,
}

impl TerminalState {
    /// Create a terminal with the given dimensions and default state.
    static fn init(rows: i64, cols: i64) TerminalState {
        ensureThemeReady()
        return TerminalState {
            grid: TerminalGrid.init(rows, cols),
            cursor_row: 0,
            cursor_col: 0,
            saved_row: 0,
            saved_col: 0,
            pending_wrap: false,
            fg_r: THEME_FG_R,
            fg_g: THEME_FG_G,
            fg_b: THEME_FG_B,
            bg_r: THEME_BG_R,
            bg_g: THEME_BG_G,
            bg_b: THEME_BG_B,
            bold: false,
            dim: false,
            italic: false,
            underline: false,
            inverse: false,
            strikethrough: false,
            default_fg_r: THEME_FG_R,
            default_fg_g: THEME_FG_G,
            default_fg_b: THEME_FG_B,
            default_bg_r: THEME_BG_R,
            default_bg_g: THEME_BG_G,
            default_bg_b: THEME_BG_B,
            palette: THEME_PALETTE,
            scroll_top: 0,
            scroll_bottom: rows - 1,
            pty_fd: -1,
            child_pid: -1,
            sel_active: false,
            sel_start_row: 0,
            sel_start_col: 0,
            sel_end_row: 0,
            sel_end_col: 0,
            cursor_visible: true,
            mode_alt_screen: false,
            mode_app_cursor: false,
            mode_bracketed_paste: false,
            mode_mouse_tracking: 0,
            mode_mouse_format: 0,
            mode_focus_events: false,
            mode_sync_output: false,
            mode_origin: false,
            mode_wraparound: true,
            mode_mouse_alt_scroll: true,
            charset_g0: 0,
            charset_g1: 0,
            active_charset: 0,
            tabstops: initTabstops(cols),
            cursor_shape: 0,
            previous_char: 0,
            title_buf: 0,
            title_len: 0,
            bell_pending: false,
            alt_grid: TerminalGrid.init(0, 0),
            alt_cursor_row: 0,
            alt_cursor_col: 0,
            alt_saved_row: 0,
            alt_saved_col: 0,
            scroll_accumulator: 0,
            viewport_row: -1,
        }
    }

    // -- Character output ---------------------------------------------------

    /// Write a character at the cursor position with current SGR attributes.
    /// Wrapping is deferred: reaching the last column sets pending_wrap,
    /// and the actual wrap (CR + LF) happens on the next printable character.
    fn putChar(cp: i64) void {
        // Apply DEC Special Graphics charset mapping
        var mapped = cp
        var charset: i64 = self.charset_g0
        if (self.active_charset == 1) { charset = self.charset_g1 }
        if (charset == 1 and mapped >= 0x60 and mapped <= 0x7E) {
            mapped = decSpecialMap(mapped)
        }

        if (self.pending_wrap) {
            if (self.mode_wraparound) {
                self.grid.setRowWrap(self.cursor_row, 1)
                self.cursor_col = 0
                self.cursor_row += 1
                if (self.cursor_row > self.scroll_bottom) {
                    self.grid.scrollUp(self.scroll_top, self.scroll_bottom)
                    self.cursor_row = self.scroll_bottom
                }
                self.pending_wrap = false
            } else {
                // No wraparound: overwrite last column
                self.pending_wrap = false
            }
        }

        const c = self.grid.getCell(self.cursor_row, self.cursor_col)
        c.codepoint = mapped
        c.fg_r = self.fg_r
        c.fg_g = self.fg_g
        c.fg_b = self.fg_b
        c.bg_r = self.bg_r
        c.bg_g = self.bg_g
        c.bg_b = self.bg_b
        c.flags = 0
        if (self.bold) { c.flags = c.flags | CELL_BOLD }
        if (self.dim) { c.flags = c.flags | CELL_DIM }
        if (self.italic) { c.flags = c.flags | CELL_ITALIC }
        if (self.underline) { c.flags = c.flags | CELL_UNDERLINE }
        if (self.inverse) { c.flags = c.flags | CELL_INVERSE }
        if (self.strikethrough) { c.flags = c.flags | CELL_STRIKETHROUGH }

        self.previous_char = mapped

        if (self.cursor_col >= self.grid.cols - 1) {
            self.pending_wrap = true
        } else {
            self.cursor_col += 1
        }
    }

    // -- C0 control characters ----------------------------------------------

    /// Linefeed (LF): move cursor down one row, scroll if at bottom of region.
    fn newline() void {
        self.grid.setRowWrap(self.cursor_row, 0)
        self.pending_wrap = false
        self.cursor_row += 1
        if (self.cursor_row > self.scroll_bottom) {
            self.grid.scrollUp(self.scroll_top, self.scroll_bottom)
            self.cursor_row = self.scroll_bottom
        }
    }

    /// Carriage return (CR): move cursor to column 0.
    fn carriageReturn() void {
        self.pending_wrap = false
        self.cursor_col = 0
    }

    /// Backspace (BS): move cursor left by one column.
    fn backspace() void {
        self.pending_wrap = false
        if (self.cursor_col > 0) {
            self.cursor_col -= 1
        }
    }

    /// Horizontal tab (HT): advance to the next tab stop.
    fn tab() void {
        self.pending_wrap = false
        self.tabForward(1)
    }

    /// Set a tab stop at the current cursor column (HTS).
    fn tabSet() void {
        if (self.cursor_col < self.tabstops.count) {
            @intToPtr(*i64, self.tabstops.items + self.cursor_col * @sizeOf(i64)).* = 1
        }
    }

    /// Clear tab stops: mode 0 = current column, mode 3 = all.
    fn tabClear(mode: i64) void {
        if (mode == 0) {
            if (self.cursor_col < self.tabstops.count) {
                @intToPtr(*i64, self.tabstops.items + self.cursor_col * @sizeOf(i64)).* = 0
            }
        } else if (mode == 3) {
            var i: i64 = 0
            while (i < self.tabstops.count) {
                @intToPtr(*i64, self.tabstops.items + i * @sizeOf(i64)).* = 0
                i += 1
            }
        }
    }

    /// Move forward count tab stops (CHT).
    fn tabForward(count: i64) void {
        var remaining = count
        var col = self.cursor_col + 1
        while (col < self.grid.cols and remaining > 0) {
            if (col < self.tabstops.count) {
                if (@intToPtr(*i64, self.tabstops.items + col * @sizeOf(i64)).* == 1) {
                    remaining -= 1
                    if (remaining == 0) {
                        self.cursor_col = col
                        return
                    }
                }
            }
            col += 1
        }
        self.cursor_col = self.grid.cols - 1
    }

    /// Move backward count tab stops (CBT).
    fn tabBackward(count: i64) void {
        var remaining = count
        var col = self.cursor_col - 1
        while (col >= 0 and remaining > 0) {
            if (col < self.tabstops.count) {
                if (@intToPtr(*i64, self.tabstops.items + col * @sizeOf(i64)).* == 1) {
                    remaining -= 1
                    if (remaining == 0) {
                        self.cursor_col = col
                        return
                    }
                }
            }
            col -= 1
        }
        self.cursor_col = 0
    }

    /// Reset tabstops to default (every 8 columns).
    fn resetTabstops() void {
        self.tabstops = initTabstops(self.grid.cols)
    }

    // -- Cursor movement (CSI A/B/C/D/H) -----------------------------------

    /// Move cursor up by count rows, clamped to scroll region top (CSI A).
    fn cursorUp(count: i64) void {
        self.pending_wrap = false
        self.cursor_row -= count
        if (self.cursor_row < self.scroll_top) {
            self.cursor_row = self.scroll_top
        }
    }

    /// Move cursor down by count rows, clamped to scroll region bottom (CSI B).
    fn cursorDown(count: i64) void {
        self.pending_wrap = false
        self.cursor_row += count
        if (self.cursor_row > self.scroll_bottom) {
            self.cursor_row = self.scroll_bottom
        }
    }

    /// Move cursor right by count columns, clamped to last column (CSI C).
    fn cursorRight(count: i64) void {
        self.pending_wrap = false
        self.cursor_col += count
        if (self.cursor_col >= self.grid.cols) {
            self.cursor_col = self.grid.cols - 1
        }
    }

    /// Move cursor left by count columns, clamped to column 0 (CSI D).
    fn cursorLeft(count: i64) void {
        self.pending_wrap = false
        self.cursor_col -= count
        if (self.cursor_col < 0) {
            self.cursor_col = 0
        }
    }

    /// Set absolute cursor position (0-indexed), clamped to grid bounds (CSI H).
    /// In origin mode, row is offset by scroll_top and clamped to scroll region.
    fn setCursorPos(row: i64, col: i64) void {
        self.pending_wrap = false
        if (self.mode_origin) {
            self.cursor_row = @max(self.scroll_top, @min(row + self.scroll_top, self.scroll_bottom))
        } else {
            self.cursor_row = @max(0, @min(row, self.grid.rows - 1))
        }
        self.cursor_col = @max(0, @min(col, self.grid.cols - 1))
    }

    // -- Scroll region (CSI r) ----------------------------------------------

    /// Set vertical scroll region (0-indexed, inclusive).
    /// Moves cursor to origin after setting the region.
    fn setScrollingRegion(top: i64, bottom: i64) void {
        var t = top
        var b = bottom
        if (t < 0) { t = 0 }
        if (b >= self.grid.rows) { b = self.grid.rows - 1 }
        if (t >= b) { return }
        self.scroll_top = t
        self.scroll_bottom = b
        self.setCursorPos(0, 0)
    }

    // -- Erase operations (CSI J/K) -----------------------------------------

    /// Erase in display: 0 = below cursor, 1 = above cursor, 2 = entire screen.
    fn eraseInDisplay(mode: i64) void {
        self.pending_wrap = false
        if (mode == 0) {
            var col = self.cursor_col
            while (col < self.grid.cols) {
                self.grid.getCell(self.cursor_row, col).* = Cell.init()
                col += 1
            }
            var row = self.cursor_row + 1
            while (row < self.grid.rows) {
                self.grid.clearLine(row)
                row += 1
            }
        } else if (mode == 1) {
            var row: i64 = 0
            while (row < self.cursor_row) {
                self.grid.clearLine(row)
                row += 1
            }
            var col: i64 = 0
            while (col <= self.cursor_col) {
                self.grid.getCell(self.cursor_row, col).* = Cell.init()
                col += 1
            }
        } else if (mode == 2) {
            self.grid.clear()
        }
    }

    /// Erase in line: 0 = right of cursor, 1 = left of cursor, 2 = entire line.
    fn eraseInLine(mode: i64) void {
        self.pending_wrap = false
        if (mode == 0) {
            var col = self.cursor_col
            while (col < self.grid.cols) {
                self.grid.getCell(self.cursor_row, col).* = Cell.init()
                col += 1
            }
        } else if (mode == 1) {
            var col: i64 = 0
            while (col <= self.cursor_col) {
                self.grid.getCell(self.cursor_row, col).* = Cell.init()
                col += 1
            }
        } else if (mode == 2) {
            self.grid.clearLine(self.cursor_row)
        }
    }

    // -- Index / scroll (IND, RI) -------------------------------------------

    /// Index: move cursor down, scroll up if at bottom of scroll region.
    fn index_() void {
        self.pending_wrap = false
        if (self.cursor_row == self.scroll_bottom) {
            self.grid.scrollUp(self.scroll_top, self.scroll_bottom)
        } else if (self.cursor_row < self.grid.rows - 1) {
            self.cursor_row += 1
        }
    }

    /// Reverse index: move cursor up, scroll down if at top of scroll region.
    fn reverseIndex() void {
        self.pending_wrap = false
        if (self.cursor_row == self.scroll_top) {
            self.grid.scrollDown(self.scroll_top, self.scroll_bottom)
        } else if (self.cursor_row > 0) {
            self.cursor_row -= 1
        }
    }

    // -- Insert / delete (CSI @, CSI P) -------------------------------------

    /// Insert count blank cells at cursor, shifting existing cells right (CSI @).
    fn insertBlanks(count: i64) void {
        self.pending_wrap = false
        const row = self.cursor_row
        const col = self.cursor_col
        const n = @min(count, self.grid.cols - col)

        // Shift cells right (iterate right-to-left to handle overlap)
        var c = self.grid.cols - 1
        while (c >= col + n) {
            self.grid.getCell(row, c).* = self.grid.getCell(row, c - n).*
            c -= 1
        }

        // Fill inserted positions with blank cells
        var i: i64 = 0
        while (i < n) {
            self.grid.getCell(row, col + i).* = Cell.init()
            i += 1
        }
    }

    /// Delete count cells at cursor, shifting remaining cells left (CSI P).
    fn deleteChars(count: i64) void {
        self.pending_wrap = false
        const row = self.cursor_row
        const col = self.cursor_col
        const n = @min(count, self.grid.cols - col)

        // Shift cells left (iterate left-to-right to handle overlap)
        var c = col
        while (c < self.grid.cols - n) {
            self.grid.getCell(row, c).* = self.grid.getCell(row, c + n).*
            c += 1
        }

        // Clear vacated cells at end of line
        c = self.grid.cols - n
        while (c < self.grid.cols) {
            self.grid.getCell(row, c).* = Cell.init()
            c += 1
        }
    }

    /// Erase N characters at cursor position without moving cursor (ECH).
    fn eraseChars(count: i64) void {
        self.pending_wrap = false
        const row = self.cursor_row
        const col = self.cursor_col
        const n = @min(count, self.grid.cols - col)
        var c = col
        while (c < col + n) {
            self.grid.getCell(row, c).* = Cell.init()
            c += 1
        }
    }

    // -- Save / restore cursor (DECSC, DECRC) -------------------------------

    /// Save cursor position (DECSC).
    fn saveCursor() void {
        self.saved_row = self.cursor_row
        self.saved_col = self.cursor_col
    }

    /// Restore cursor position (DECRC).
    fn restoreCursor() void {
        self.pending_wrap = false
        self.cursor_row = self.saved_row
        self.cursor_col = self.saved_col
    }

    // -- SGR attributes -----------------------------------------------------

    /// Reset all SGR attributes to defaults.
    fn resetAttributes() void {
        self.fg_r = self.default_fg_r
        self.fg_g = self.default_fg_g
        self.fg_b = self.default_fg_b
        self.bg_r = self.default_bg_r
        self.bg_g = self.default_bg_g
        self.bg_b = self.default_bg_b
        self.bold = false
        self.dim = false
        self.italic = false
        self.underline = false
        self.inverse = false
        self.strikethrough = false
    }

    // -- Bell ---------------------------------------------------------------

    /// Signal a bell event (BEL).
    fn bell() void {
        self.bell_pending = true
    }

    // -- Title / PWD --------------------------------------------------------

    /// Set the terminal title from OSC buffer data.
    fn setTitle(buf: List(i64), start: i64, len: i64) void {
        if (len <= 0) { return }
        // Allocate or reuse title buffer
        if (self.title_buf == 0 or len > self.title_len) {
            self.title_buf = alloc(self.title_buf, len)
        }
        self.title_len = len
        var i: i64 = 0
        while (i < len) {
            @intToPtr(*u8, self.title_buf + i).* = @intCast(u8, buf.get(start + i))
            i += 1
        }
    }

    /// Set the working directory from OSC 7 data (stored for future use).
    fn setPwd(buf: List(i64), start: i64, len: i64) void {
        // Stored for future use (e.g., new tab in same directory)
    }

    // -- Soft Reset (DECSTR) ------------------------------------------------

    /// Soft reset: resets modes and attributes without clearing the screen.
    fn softReset() void {
        self.resetAttributes()
        self.cursor_visible = true
        self.mode_app_cursor = false
        self.mode_bracketed_paste = false
        self.mode_mouse_tracking = 0
        self.mode_mouse_format = 0
        self.mode_focus_events = false
        self.mode_sync_output = false
        self.mode_origin = false
        self.mode_wraparound = true
        self.mode_mouse_alt_scroll = true
        self.scroll_top = 0
        self.scroll_bottom = self.grid.rows - 1
        self.charset_g0 = 0
        self.charset_g1 = 0
        self.active_charset = 0
        self.cursor_shape = 0
        self.pending_wrap = false
    }

    // -- DEC Private Modes --------------------------------------------------

    /// Set or reset a DEC private mode.
    fn setDecMode(mode: i64, enable: bool) void {
        if (mode == 1) {
            self.mode_app_cursor = enable
        } else if (mode == 6) {
            self.mode_origin = enable
            self.setCursorPos(0, 0)
        } else if (mode == 7) {
            self.mode_wraparound = enable
        } else if (mode == 25) {
            self.cursor_visible = enable
        } else if (mode == 47 or mode == 1047) {
            // Legacy alt screen (no cursor save/restore)
            if (enable) {
                self.enterAltScreen()
            } else {
                self.leaveAltScreen()
            }
        } else if (mode == 1048) {
            // Save/restore cursor only (used alongside 47/1047)
            if (enable) {
                self.saveCursor()
            } else {
                self.restoreCursor()
            }
        } else if (mode == 1049) {
            if (enable) {
                self.enterAltScreen()
            } else {
                self.leaveAltScreen()
            }
        } else if (mode == 1000) {
            if (enable) { self.mode_mouse_tracking = 1000 } else { self.mode_mouse_tracking = 0 }
        } else if (mode == 1002) {
            if (enable) { self.mode_mouse_tracking = 1002 } else { self.mode_mouse_tracking = 0 }
        } else if (mode == 1003) {
            if (enable) { self.mode_mouse_tracking = 1003 } else { self.mode_mouse_tracking = 0 }
        } else if (mode == 1004) {
            self.mode_focus_events = enable
        } else if (mode == 1006) {
            if (enable) { self.mode_mouse_format = 1006 } else { self.mode_mouse_format = 0 }
        } else if (mode == 2004) {
            self.mode_bracketed_paste = enable
        } else if (mode == 2026) {
            self.mode_sync_output = enable
        } else if (mode == 1007) {
            self.mode_mouse_alt_scroll = enable
        }
    }

    /// Enter alternate screen buffer: save cursor and swap to a fresh grid.
    fn enterAltScreen() void {
        if (self.mode_alt_screen) { return }
        self.viewport_row = -1
        self.alt_cursor_row = self.cursor_row
        self.alt_cursor_col = self.cursor_col
        self.alt_saved_row = self.saved_row
        self.alt_saved_col = self.saved_col
        self.alt_grid = self.grid
        self.grid = TerminalGrid.init(self.grid.rows, self.grid.cols)
        self.grid.scrollback_enabled = 0
        self.cursor_row = 0
        self.cursor_col = 0
        self.scroll_top = 0
        self.scroll_bottom = self.grid.rows - 1
        self.pending_wrap = false
        self.mode_alt_screen = true
    }

    /// Leave alternate screen buffer: restore saved grid and cursor.
    fn leaveAltScreen() void {
        if (!self.mode_alt_screen) { return }
        self.grid = self.alt_grid
        self.cursor_row = self.alt_cursor_row
        self.cursor_col = self.alt_cursor_col
        self.saved_row = self.alt_saved_row
        self.saved_col = self.alt_saved_col
        self.scroll_top = 0
        self.scroll_bottom = self.grid.rows - 1
        self.pending_wrap = false
        self.mode_alt_screen = false
        self.alt_grid = TerminalGrid.init(0, 0)
    }

    // -- Device Status Report / Device Attributes ---------------------------

    /// Send cursor position report: ESC [ row ; col R (1-indexed).
    fn sendCursorPositionReport() void {
        if (self.pty_fd < 0) { return }
        // Build response: ESC [ Pr ; Pc R
        writeStr(self.pty_fd, "\x1b[")
        self.writeDecimal(self.pty_fd, self.cursor_row + 1)
        writeStr(self.pty_fd, ";")
        self.writeDecimal(self.pty_fd, self.cursor_col + 1)
        writeStr(self.pty_fd, "R")
    }

    /// Send primary device attributes response (VT220 + color, matches Ghostty).
    fn sendPrimaryDeviceAttributes() void {
        if (self.pty_fd < 0) { return }
        writeStr(self.pty_fd, "\x1b[?62;22c")
    }

    /// Send secondary device attributes response (matches Ghostty).
    fn sendSecondaryDeviceAttributes() void {
        if (self.pty_fd < 0) { return }
        writeStr(self.pty_fd, "\x1b[>1;10;0c")
    }

    /// Send operating status report: terminal OK.
    fn sendOperatingStatus() void {
        if (self.pty_fd < 0) { return }
        writeStr(self.pty_fd, "\x1b[0n")
    }

    /// Write a decimal integer to an fd as ASCII digits.
    fn writeDecimal(fd: i64, val: i64) void {
        if (val == 0) {
            writeByte(fd, '0')
            return
        }
        // Stack digits (max 5 digits for terminal coords)
        var digits: i64 = 0
        var count: i64 = 0
        var v = val
        while (v > 0) {
            digits = digits * 10 + (v % 10)
            count += 1
            v = v / 10
        }
        // Write digits in correct order
        while (count > 0) {
            writeByte(fd, '0' + (digits % 10))
            digits = digits / 10
            count -= 1
        }
    }

    // -- Resize -------------------------------------------------------------

    /// Resize rows only (no column change), preserving content and wrap flags.
    /// Discards scrollback (active_start resets to 0 in new grid).
    fn resizeRowsOnly(new_rows: i64) void {
        var new_grid = TerminalGrid.init(new_rows, self.grid.cols)
        const copy_rows = @min(self.grid.rows, new_rows)

        var row: i64 = 0
        while (row < copy_rows) {
            const dst = new_grid.cells.items + (row * self.grid.cols) * @sizeOf(Cell)
            const src = self.grid.cells.items + ((self.grid.active_start + row) * self.grid.cols) * @sizeOf(Cell)
            memcpy(dst, src, self.grid.cols * @sizeOf(Cell))
            new_grid.setRowWrap(row, self.grid.getRowWrap(row))
            row += 1
        }

        self.grid = new_grid
        self.viewport_row = -1
        self.scroll_top = 0
        self.scroll_bottom = new_rows - 1
        self.cursor_row = @min(self.cursor_row, new_rows - 1)
        self.pending_wrap = false
        self.tabstops = initTabstops(self.grid.cols)
    }

    /// Resize the terminal to new dimensions with content reflow.
    /// Soft-wrapped lines are joined into logical lines and re-wrapped
    /// to the new column width. Cursor position is tracked through reflow.
    fn resize(new_rows: i64, new_cols: i64) void {
        if (new_rows == self.grid.rows and new_cols == self.grid.cols) { return }
        // Alt screen: TUI apps redraw after SIGWINCH, so skip reflow entirely.
        // Just create a blank grid and clamp cursor (like Ghostty).
        if (self.mode_alt_screen) {
            if (self.alt_grid.rows > 0) {
                self.alt_grid = TerminalGrid.init(new_rows, new_cols)
            }
            self.grid = TerminalGrid.init(new_rows, new_cols)
            if (self.cursor_row >= new_rows) { self.cursor_row = new_rows - 1 }
            if (self.cursor_col >= new_cols) { self.cursor_col = new_cols - 1 }
            self.scroll_top = 0
            self.scroll_bottom = new_rows - 1
            self.pending_wrap = false
            self.tabstops = initTabstops(new_cols)
            return
        }
        // When in alt screen, also resize the saved main grid
        if (self.alt_grid.rows > 0) {
            self.alt_grid = TerminalGrid.init(new_rows, new_cols)
        }
        if (new_cols == self.grid.cols) {
            self.resizeRowsOnly(new_rows)
            return
        }

        // Temp storage for reflowed output
        var out_cells: List(Cell) = undefined
        out_cells.items = 0
        out_cells.count = 0
        out_cells.capacity = 0

        var out_wraps: List(i64) = undefined
        out_wraps.items = 0
        out_wraps.count = 0
        out_wraps.capacity = 0

        var out_rows: i64 = 0
        var new_cursor_row: i64 = 0
        var new_cursor_col: i64 = 0

        // Process each logical line (sequence of soft-wrapped rows)
        var src_row: i64 = 0
        while (src_row < self.grid.rows) {
            // Find extent of this logical line
            var line_start = src_row
            while (src_row < self.grid.rows - 1 and self.grid.getRowWrap(src_row) == 1) {
                src_row += 1
            }
            var line_end = src_row
            src_row += 1

            // Total cells in logical line
            var total_cells = (line_end - line_start + 1) * self.grid.cols

            // Trim trailing blank cells
            var content_len = total_cells
            while (content_len > 0) {
                var idx = content_len - 1
                var r = line_start + idx / self.grid.cols
                var c = idx % self.grid.cols
                var cell = self.grid.getCell(r, c)
                if (cell.codepoint != 0 and cell.codepoint != ' ') {
                    break
                }
                content_len -= 1
            }

            // Check if cursor is in this logical line
            var cursor_in_line = (self.cursor_row >= line_start and self.cursor_row <= line_end)
            var cursor_abs: i64 = 0
            if (cursor_in_line) {
                cursor_abs = (self.cursor_row - line_start) * self.grid.cols + self.cursor_col
            }

            // Number of output rows for this logical line
            var num_out: i64 = 1
            if (content_len > 0) {
                num_out = (content_len + new_cols - 1) / new_cols
            }

            var first_out = out_rows

            // Emit re-wrapped rows
            var row_idx: i64 = 0
            while (row_idx < num_out) {
                var col: i64 = 0
                while (col < new_cols) {
                    var abs_idx = row_idx * new_cols + col
                    if (abs_idx < total_cells) {
                        var r = line_start + abs_idx / self.grid.cols
                        var c = abs_idx % self.grid.cols
                        out_cells.append(self.grid.getCell(r, c).*)
                    } else {
                        out_cells.append(Cell.init())
                    }
                    col += 1
                }

                if (row_idx < num_out - 1) {
                    out_wraps.append(1)
                } else {
                    out_wraps.append(0)
                }

                out_rows += 1
                row_idx += 1
            }

            // Map cursor position within this logical line
            if (cursor_in_line) {
                if (content_len == 0) {
                    new_cursor_row = first_out
                    new_cursor_col = @min(cursor_abs, new_cols - 1)
                } else {
                    var c_row = cursor_abs / new_cols
                    var c_col = cursor_abs % new_cols
                    if (c_row >= num_out) {
                        c_row = num_out - 1
                        c_col = new_cols - 1
                    }
                    new_cursor_row = first_out + c_row
                    new_cursor_col = c_col
                }
            }
        }

        // Build new grid, keeping cursor visible at bottom of view
        var new_grid = TerminalGrid.init(new_rows, new_cols)

        var skip: i64 = 0
        if (out_rows > new_rows) {
            skip = new_cursor_row - new_rows + 1
            if (skip < 0) { skip = 0 }
            if (skip + new_rows > out_rows) { skip = out_rows - new_rows }
        }

        // Copy output rows into new grid
        var dst_row: i64 = 0
        var src_idx = skip
        while (src_idx < out_rows and dst_row < new_rows) {
            var col: i64 = 0
            while (col < new_cols) {
                var cell_idx = src_idx * new_cols + col
                new_grid.getCell(dst_row, col).* = @intToPtr(*Cell, out_cells.items + cell_idx * @sizeOf(Cell)).*
                col += 1
            }
            new_grid.setRowWrap(dst_row, @intToPtr(*i64, out_wraps.items + src_idx * @sizeOf(i64)).*)
            dst_row += 1
            src_idx += 1
        }

        // Adjust cursor for skipped rows
        new_cursor_row -= skip
        if (new_cursor_row < 0) { new_cursor_row = 0 }
        if (new_cursor_row >= new_rows) { new_cursor_row = new_rows - 1 }
        if (new_cursor_col >= new_cols) { new_cursor_col = new_cols - 1 }

        self.grid = new_grid
        self.cursor_row = new_cursor_row
        self.cursor_col = new_cursor_col
        self.viewport_row = -1
        self.scroll_top = 0
        self.scroll_bottom = new_rows - 1
        self.pending_wrap = false
        self.tabstops = initTabstops(new_cols)
    }

    // -- Selection --------------------------------------------------------------

    /// Begin a new selection at (row, col). Marks selection active.
    fn selectionStart(row: i64, col: i64) void {
        self.sel_active = true
        self.sel_start_row = row
        self.sel_start_col = col
        self.sel_end_row = row
        self.sel_end_col = col
        self.markSelection()
    }

    /// Update the selection endpoint to (row, col) and recompute flags.
    fn selectionUpdate(row: i64, col: i64) void {
        self.sel_end_row = row
        self.sel_end_col = col
        self.markSelection()
    }

    /// Clear the selection and remove all CELL_SELECTED flags.
    fn selectionClear() void {
        self.sel_active = false
        self.clearSelectionFlags()
    }

    /// Remove CELL_SELECTED flag from every cell in the grid.
    fn clearSelectionFlags() void {
        var r: i64 = 0
        while (r < self.grid.rows) {
            var c: i64 = 0
            while (c < self.grid.cols) {
                const cell = self.grid.getCell(r, c)
                if ((cell.flags & CELL_SELECTED) != 0) {
                    cell.flags = cell.flags - CELL_SELECTED
                }
                c += 1
            }
            r += 1
        }
    }

    /// Recompute CELL_SELECTED flags on the grid based on current selection.
    fn markSelection() void {
        self.clearSelectionFlags()
        if (!self.sel_active) { return }

        // Normalize: ensure (sr,sc) <= (er,ec) lexicographically
        var sr = self.sel_start_row
        var sc = self.sel_start_col
        var er = self.sel_end_row
        var ec = self.sel_end_col
        if (sr > er or (sr == er and sc > ec)) {
            const tr = sr
            const tc = sc
            sr = er
            sc = ec
            er = tr
            ec = tc
        }

        // Clamp to grid bounds
        if (sr < 0) { sr = 0 }
        if (er >= self.grid.rows) { er = self.grid.rows - 1 }

        var row = sr
        while (row <= er) {
            var col_start: i64 = 0
            var col_end = self.grid.cols - 1

            if (row == sr) { col_start = sc }
            if (row == er) { col_end = ec }

            // Clamp columns
            if (col_start < 0) { col_start = 0 }
            if (col_end >= self.grid.cols) { col_end = self.grid.cols - 1 }

            var col = col_start
            while (col <= col_end) {
                self.grid.getCell(row, col).flags = self.grid.getCell(row, col).flags | CELL_SELECTED
                col += 1
            }
            row += 1
        }
    }

    /// Write selected text into a byte buffer. Returns number of bytes written.
    /// Codepoints are written as single bytes (ASCII). Rows separated by newlines.
    /// Trailing spaces on each row are trimmed.
    fn writeSelectedText(buf_ptr: i64, buf_cap: i64) i64 {
        if (!self.sel_active) { return 0 }

        // Normalize
        var sr = self.sel_start_row
        var sc = self.sel_start_col
        var er = self.sel_end_row
        var ec = self.sel_end_col
        if (sr > er or (sr == er and sc > ec)) {
            const tr = sr
            const tc = sc
            sr = er
            sc = ec
            er = tr
            ec = tc
        }

        if (sr < 0) { sr = 0 }
        if (er >= self.grid.rows) { er = self.grid.rows - 1 }

        var pos: i64 = 0
        var row = sr
        while (row <= er) {
            var col_start: i64 = 0
            var col_end = self.grid.cols - 1

            if (row == sr) { col_start = sc }
            if (row == er) { col_end = ec }

            if (col_start < 0) { col_start = 0 }
            if (col_end >= self.grid.cols) { col_end = self.grid.cols - 1 }

            // Find last non-blank column in this row's selection range
            var last_nonblank = col_start - 1
            var scan = col_start
            while (scan <= col_end) {
                const cp = self.grid.getCell(row, scan).codepoint
                if (cp != 0 and cp != ' ') {
                    last_nonblank = scan
                }
                scan += 1
            }

            // Write characters up to last non-blank
            var col = col_start
            while (col <= last_nonblank) {
                if (pos >= buf_cap) { return pos }
                var cp = self.grid.getCell(row, col).codepoint
                if (cp == 0) { cp = ' ' }
                @intToPtr(*u8, buf_ptr + pos).* = @intCast(u8, cp)
                pos += 1
                col += 1
            }

            // Add newline between rows (not after last)
            if (row < er) {
                if (pos >= buf_cap) { return pos }
                @intToPtr(*u8, buf_ptr + pos).* = @intCast(u8, '\n')
                pos += 1
            }
            row += 1
        }
        return pos
    }

    /// Scroll the viewport by delta rows. delta > 0 = show older content (scroll up).
    /// Ported from Ghostty's scrollViewport.
    fn scrollViewport(delta: i64) void {
        if (self.mode_alt_screen) { return }
        if (self.grid.active_start == 0) { return }

        if (delta > 0) {
            // Scroll up — show older content
            if (self.viewport_row < 0) {
                self.viewport_row = self.grid.active_start - delta
            } else {
                self.viewport_row = self.viewport_row - delta
            }
            if (self.viewport_row < 0) { self.viewport_row = 0 }
        } else if (delta < 0) {
            // Scroll down — show newer content
            if (self.viewport_row >= 0) {
                self.viewport_row = self.viewport_row - delta
                if (self.viewport_row >= self.grid.active_start) {
                    self.viewport_row = -1
                }
            }
        }

        if (self.sel_active) { self.selectionClear() }
    }

    /// Snap viewport to bottom (follow active).
    fn scrollToBottom() void {
        self.viewport_row = -1
    }

    /// Return true if viewport is at bottom (following active output).
    fn viewportIsBottom() bool {
        return self.viewport_row < 0
    }

    /// Handle a scroll wheel event. Ported from Ghostty's Surface.scrollCallback.
    /// Normalizes pixel deltas to cell-row units, accumulates fractional scroll,
    /// and dispatches as SGR mouse wheel events when mouse reporting is active.
    /// delta: scroll delta in millipoints (points * 1000, fixed-point).
    /// precise: 1 for trackpad (pixel deltas), 0 for discrete mouse wheel.
    /// cell_height: cell height in millipoints (points * 1000).
    /// col, row: 1-indexed terminal grid position.
    fn scrollEvent(fd: i64, delta: i64, precise: i64, cell_height: i64, col: i64, row: i64) void {
        if (cell_height <= 0) { return }

        // Normalize delta to millipoints.
        // Ghostty: precision scrolls use raw pixel deltas (Swift already 2x'd).
        // Discrete scrolls convert "line ticks" to pixels: tick * cell_height * 3.
        var adjusted = delta
        if (precise == 0) {
            adjusted = delta * cell_height * 3 / 1000
        }

        // Accumulate fractional scroll (Ghostty: mouse.pending_scroll_y)
        self.scroll_accumulator = self.scroll_accumulator + adjusted

        // Not enough for a full cell yet
        if (self.scroll_accumulator < 0) {
            if (self.scroll_accumulator > 0 - cell_height) { return }
        } else {
            if (self.scroll_accumulator < cell_height) { return }
        }

        // Calculate row delta (Ghostty: amount = poff / cell_size)
        var rows = self.scroll_accumulator / cell_height
        self.scroll_accumulator = self.scroll_accumulator - rows * cell_height

        // If mouse reporting active, send SGR wheel events
        // (Ghostty: self.isMouseReporting() → mouseReport)
        if (self.mode_mouse_tracking != 0) {
            var button: i64 = 65
            if (rows > 0) { button = 64 }
            if (rows < 0) { rows = 0 - rows }
            var i: i64 = 0
            while (i < rows) {
                mouseToTerminalBytes(fd, button, col, row, 1)
                i += 1
            }
            return
        }

        // Ghostty: alt screen + mouse_alternate_scroll mode → cursor keys
        if (self.mode_alt_screen and self.mode_mouse_alt_scroll) {
            // Convert scroll to cursor up/down keys
            var key_rows = rows
            if (key_rows < 0) { key_rows = 0 - key_rows }
            var j: i64 = 0
            while (j < key_rows) {
                if (rows > 0) {
                    writeStr(fd, "\x1b[A")
                } else {
                    writeStr(fd, "\x1b[B")
                }
                j += 1
            }
            return
        }

        // Scroll viewport (scrollback buffer)
        self.scrollViewport(rows)
    }
}

// ============================================================================
// PTY byte capture — records bytes sent by keyToTerminalBytes for inspector
// ============================================================================

var g_capture_active: bool = false
var g_capture_bytes: List(i64) = undefined
var g_capture_init: bool = false

fn captureBegin() void {
    if (!g_capture_init) {
        g_capture_bytes.items = 0
        g_capture_bytes.count = 0
        g_capture_bytes.capacity = 0
        g_capture_init = true
    }
    g_capture_bytes.count = 0
    g_capture_active = true
}

fn captureEnd() List(i64) {
    g_capture_active = false
    return g_capture_bytes.clone()
}

// ============================================================================
// Terminal key input → VT100 bytes
// ============================================================================

/// Write a string to an fd.
fn writeStr(fd: i64, s: string) void {
    if (g_capture_active) {
        var i: i64 = 0
        while (i < @lenOf(s)) {
            g_capture_bytes.append(@intToPtr(*u8, @ptrOf(s) + i).*)
            i += 1
        }
    }
    fd_write(fd, @ptrOf(s), @lenOf(s))
}

/// Write a single byte to an fd.
var g_key_byte: i64 = 0

fn writeByte(fd: i64, val: i64) void {
    if (g_key_byte == 0) { g_key_byte = alloc(0, 1) }
    @intToPtr(*u8, g_key_byte).* = @intCast(u8, val)
    if (g_capture_active) {
        g_capture_bytes.append(val)
    }
    fd_write(fd, g_key_byte, 1)
}

/// Write a decimal integer to an fd as ASCII digits (free function version).
fn writeDecimalFree(fd: i64, val: i64) void {
    if (val == 0) {
        writeByte(fd, '0')
        return
    }
    var digits: i64 = 0
    var count: i64 = 0
    var v = val
    while (v > 0) {
        digits = digits * 10 + (v % 10)
        count += 1
        v = v / 10
    }
    while (count > 0) {
        writeByte(fd, '0' + (digits % 10))
        digits = digits / 10
        count -= 1
    }
}

/// Encode a mouse event as SGR (mode 1006) sequence and write to PTY fd.
/// button: 0=left, 1=middle, 2=right, 32=drag, 64=wheel up, 65=wheel down.
/// col, row: 1-indexed terminal coordinates.
/// pressed: 1 for press/wheel, 0 for release.
/// Format: ESC [ < button ; col ; row M (press) or m (release).
fn mouseToTerminalBytes(fd: i64, button: i64, col: i64, row: i64, pressed: i64) void {
    writeStr(fd, "\x1b[<")
    writeDecimalFree(fd, button)
    writeStr(fd, ";")
    writeDecimalFree(fd, col)
    writeStr(fd, ";")
    writeDecimalFree(fd, row)
    if (pressed == 1) {
        writeStr(fd, "M")
    } else {
        writeStr(fd, "m")
    }
}

/// Translate a key event into VT100 bytes and write to the given fd.
/// Handles modifiers (Shift, Alt, Ctrl) using xterm-style encoding:
///   modifier param = 1 + (shift?1:0) + (alt?2:0) + (ctrl?4:0)
fn keyToTerminalBytes(fd: i64, key: i64, mods: i64, app_cursor: bool) void {
    const has_ctrl = (mods & MOD_CTRL) != 0
    const has_shift = (mods & MOD_SHIFT) != 0
    const has_alt = (mods & MOD_ALT) != 0
    const has_mods = has_ctrl or has_shift or has_alt

    // Compute xterm modifier parameter: 1 + shift?1 + alt?2 + ctrl?4
    var mod_param: i64 = 1
    if (has_shift) { mod_param = mod_param + 1 }
    if (has_alt) { mod_param = mod_param + 2 }
    if (has_ctrl) { mod_param = mod_param + 4 }

    // Ctrl+key → control character (0x01-0x1A)
    if (has_ctrl and !has_shift and !has_alt) {
        if (key >= 'a' and key <= 'z') { writeByte(fd, key - 0x60); return }
        if (key >= 'A' and key <= 'Z') { writeByte(fd, key - 0x40); return }
    }

    // Shift+Tab → backtab (ESC [ Z)
    if (key == KEY_TAB and has_shift) {
        writeStr(fd, "\x1b[Z")
        return
    }

    // Arrow keys
    if (key == KEY_ARROW_UP or key == KEY_ARROW_DOWN or key == KEY_ARROW_RIGHT or key == KEY_ARROW_LEFT) {
        var letter: i64 = 'A'
        if (key == KEY_ARROW_DOWN) { letter = 'B' }
        if (key == KEY_ARROW_RIGHT) { letter = 'C' }
        if (key == KEY_ARROW_LEFT) { letter = 'D' }

        if (has_mods) {
            // Modified arrows: ESC [ 1 ; mod letter
            writeStr(fd, "\x1b[1;")
            writeDecimalFree(fd, mod_param)
            writeByte(fd, letter)
        } else if (app_cursor) {
            // App cursor mode: ESC O letter
            writeStr(fd, "\x1b")
            writeByte(fd, 'O')
            writeByte(fd, letter)
        } else {
            // Normal mode: ESC [ letter
            writeStr(fd, "\x1b[")
            writeByte(fd, letter)
        }
        return
    }

    // Home / End
    if (key == KEY_HOME or key == KEY_END) {
        var letter: i64 = 'H'
        if (key == KEY_END) { letter = 'F' }

        if (has_mods) {
            writeStr(fd, "\x1b[1;")
            writeDecimalFree(fd, mod_param)
            writeByte(fd, letter)
        } else if (app_cursor) {
            writeStr(fd, "\x1b")
            writeByte(fd, 'O')
            writeByte(fd, letter)
        } else {
            writeStr(fd, "\x1b[")
            writeByte(fd, letter)
        }
        return
    }

    // Delete (3~), PageUp (5~), PageDown (6~) — tilde-encoded
    if (key == KEY_DELETE or key == KEY_PAGE_UP or key == KEY_PAGE_DOWN) {
        var num: i64 = 3
        if (key == KEY_PAGE_UP) { num = 5 }
        if (key == KEY_PAGE_DOWN) { num = 6 }

        if (has_mods) {
            writeStr(fd, "\x1b[")
            writeDecimalFree(fd, num)
            writeStr(fd, ";")
            writeDecimalFree(fd, mod_param)
            writeStr(fd, "~")
        } else {
            writeStr(fd, "\x1b[")
            writeDecimalFree(fd, num)
            writeStr(fd, "~")
        }
        return
    }

    // Function keys F1-F4 (SS3: ESC O P/Q/R/S)
    if (key >= KEY_F1 and key <= KEY_F4) {
        var letter: i64 = 'P'
        if (key == KEY_F2) { letter = 'Q' }
        if (key == KEY_F3) { letter = 'R' }
        if (key == KEY_F4) { letter = 'S' }

        if (has_mods) {
            writeStr(fd, "\x1b[1;")
            writeDecimalFree(fd, mod_param)
            writeByte(fd, letter)
        } else {
            writeStr(fd, "\x1b")
            writeByte(fd, 'O')
            writeByte(fd, letter)
        }
        return
    }

    // Function keys F5-F12 (tilde encoding)
    if (key >= KEY_F5 and key <= KEY_F12) {
        // F5=15, F6=17, F7=18, F8=19, F9=20, F10=21, F11=23, F12=24
        var num: i64 = 15
        if (key == KEY_F6) { num = 17 }
        if (key == KEY_F7) { num = 18 }
        if (key == KEY_F8) { num = 19 }
        if (key == KEY_F9) { num = 20 }
        if (key == KEY_F10) { num = 21 }
        if (key == KEY_F11) { num = 23 }
        if (key == KEY_F12) { num = 24 }

        if (has_mods) {
            writeStr(fd, "\x1b[")
            writeDecimalFree(fd, num)
            writeStr(fd, ";")
            writeDecimalFree(fd, mod_param)
            writeStr(fd, "~")
        } else {
            writeStr(fd, "\x1b[")
            writeDecimalFree(fd, num)
            writeStr(fd, "~")
        }
        return
    }

    // Simple special keys (no modifiers)
    if (key == KEY_ENTER) { writeStr(fd, "\r"); return }
    if (key == KEY_TAB) { writeStr(fd, "\t"); return }
    if (key == KEY_BACKSPACE) { writeStr(fd, "\x7f"); return }
    if (key == KEY_ESCAPE) { writeStr(fd, "\x1b"); return }

    // Alt+printable → ESC + key (meta prefix)
    if (has_alt and !has_ctrl and key >= 32 and key <= 126) {
        writeStr(fd, "\x1b")
        writeByte(fd, key)
        return
    }

    // Printable ASCII → write the byte directly
    if (key >= 32 and key <= 126) {
        writeByte(fd, key)
    }
}

// ============================================================================
// Tests — Grid
// ============================================================================

test "grid init" {
    var g = TerminalGrid.init(24, 80)
    @assertEq(g.rows, 24)
    @assertEq(g.cols, 80)
    @assertEq(g.cells.count, 1920)
}

test "grid getCell read write" {
    var g = TerminalGrid.init(3, 4)
    const c = g.getCell(1, 2)
    @assert(c.isBlank())
    c.codepoint = 'X'
    @assertEq(g.getCell(1, 2).codepoint, 'X')
}

test "grid clear" {
    var g = TerminalGrid.init(3, 4)
    g.getCell(0, 0).codepoint = 'A'
    g.getCell(2, 3).codepoint = 'Z'
    g.clear()
    @assert(g.getCell(0, 0).isBlank())
    @assert(g.getCell(2, 3).isBlank())
}

test "grid clearLine leaves other rows" {
    var g = TerminalGrid.init(3, 4)
    g.getCell(0, 0).codepoint = 'K'
    g.getCell(1, 0).codepoint = 'A'
    g.getCell(1, 3).codepoint = 'Z'
    g.clearLine(1)
    @assert(g.getCell(1, 0).isBlank())
    @assert(g.getCell(1, 3).isBlank())
    @assertEq(g.getCell(0, 0).codepoint, 'K')
}

test "grid scrollUp shifts content" {
    var g = TerminalGrid.init(3, 4)
    g.getCell(0, 0).codepoint = 'A'
    g.getCell(1, 0).codepoint = 'B'
    g.getCell(2, 0).codepoint = 'C'
    g.scrollUp(0, 2)
    @assertEq(g.getCell(0, 0).codepoint, 'B')
    @assertEq(g.getCell(1, 0).codepoint, 'C')
    @assert(g.getCell(2, 0).isBlank())
}

test "grid scrollUp preserves default colors" {
    var g = TerminalGrid.init(3, 4)
    g.getCell(0, 0).codepoint = 'A'
    g.scrollUp(0, 2)
    @assertEq(g.getCell(2, 0).fg_r, 217)
    @assertEq(g.getCell(2, 0).bg_r, 12)
}

test "grid scrollDown shifts content" {
    var g = TerminalGrid.init(3, 4)
    g.getCell(0, 0).codepoint = 'A'
    g.getCell(1, 0).codepoint = 'B'
    g.getCell(2, 0).codepoint = 'C'
    g.scrollDown(0, 2)
    @assert(g.getCell(0, 0).isBlank())
    @assertEq(g.getCell(1, 0).codepoint, 'A')
    @assertEq(g.getCell(2, 0).codepoint, 'B')
}

// ============================================================================
// Tests — State: character output
// ============================================================================

test "putChar basic" {
    var t = TerminalState.init(24, 80)
    t.putChar('H')
    t.putChar('i')
    @assertEq(t.cursor_col, 2)
    @assertEq(t.grid.getCell(0, 0).codepoint, 'H')
    @assertEq(t.grid.getCell(0, 1).codepoint, 'i')
}

test "putChar applies SGR attributes" {
    var t = TerminalState.init(24, 80)
    t.fg_r = 255
    t.fg_g = 0
    t.fg_b = 0
    t.bold = true
    t.putChar('X')
    const c = t.grid.getCell(0, 0)
    @assertEq(c.fg_r, 255)
    @assertEq(c.fg_g, 0)
    @assertEq(c.flags & CELL_BOLD, CELL_BOLD)
}

test "putChar deferred wrap at last column" {
    var t = TerminalState.init(3, 4)
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    // Cursor stays at last column with pending wrap
    @assertEq(t.cursor_col, 3)
    @assertEq(t.pending_wrap, true)
    // Next character triggers the deferred wrap
    t.putChar('E')
    @assertEq(t.cursor_row, 1)
    @assertEq(t.cursor_col, 1)
    @assertEq(t.grid.getCell(1, 0).codepoint, 'E')
    @assertEq(t.pending_wrap, false)
}

test "putChar wrap scrolls at bottom" {
    var t = TerminalState.init(3, 4)
    t.cursor_row = 2
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    // pending_wrap is set at end of last row
    @assertEq(t.pending_wrap, true)
    t.putChar('E')
    // Should have scrolled: cursor still on row 2
    @assertEq(t.cursor_row, 2)
    @assertEq(t.grid.getCell(2, 0).codepoint, 'E')
}

// ============================================================================
// Tests — State: C0 controls
// ============================================================================

test "newline moves down" {
    var t = TerminalState.init(24, 80)
    t.putChar('A')
    t.newline()
    @assertEq(t.cursor_row, 1)
    // LF only moves down, does not reset column (VT100)
    @assertEq(t.cursor_col, 1)
}

test "newline scrolls at bottom" {
    var t = TerminalState.init(3, 4)
    t.cursor_row = 2
    t.putChar('X')
    t.newline()
    @assertEq(t.cursor_row, 2)
    @assert(t.grid.getCell(0, 0).isBlank())
}

test "carriageReturn resets column" {
    var t = TerminalState.init(24, 80)
    t.putChar('A')
    t.putChar('B')
    t.carriageReturn()
    @assertEq(t.cursor_col, 0)
    @assertEq(t.pending_wrap, false)
}

test "backspace clamps at zero" {
    var t = TerminalState.init(24, 80)
    t.putChar('A')
    t.putChar('B')
    t.backspace()
    @assertEq(t.cursor_col, 1)
    t.backspace()
    @assertEq(t.cursor_col, 0)
    t.backspace()
    @assertEq(t.cursor_col, 0)
}

test "tab advances to next stop" {
    var t = TerminalState.init(24, 80)
    t.tab()
    @assertEq(t.cursor_col, 8)
    t.putChar('A')
    t.tab()
    @assertEq(t.cursor_col, 16)
}

// ============================================================================
// Tests — State: cursor movement
// ============================================================================

test "cursorUp clamps at scroll top" {
    var t = TerminalState.init(24, 80)
    t.cursor_row = 5
    t.cursorUp(3)
    @assertEq(t.cursor_row, 2)
    t.cursorUp(100)
    @assertEq(t.cursor_row, 0)
}

test "cursorDown clamps at scroll bottom" {
    var t = TerminalState.init(24, 80)
    t.cursorDown(10)
    @assertEq(t.cursor_row, 10)
    t.cursorDown(100)
    @assertEq(t.cursor_row, 23)
}

test "cursorRight clamps at last column" {
    var t = TerminalState.init(24, 80)
    t.cursorRight(10)
    @assertEq(t.cursor_col, 10)
    t.cursorRight(100)
    @assertEq(t.cursor_col, 79)
}

test "cursorLeft clamps at zero" {
    var t = TerminalState.init(24, 80)
    t.cursor_col = 10
    t.cursorLeft(3)
    @assertEq(t.cursor_col, 7)
    t.cursorLeft(100)
    @assertEq(t.cursor_col, 0)
}

test "setCursorPos clamps to bounds" {
    var t = TerminalState.init(24, 80)
    t.setCursorPos(5, 10)
    @assertEq(t.cursor_row, 5)
    @assertEq(t.cursor_col, 10)
    t.setCursorPos(100, 200)
    @assertEq(t.cursor_row, 23)
    @assertEq(t.cursor_col, 79)
}

test "setCursorPos clears pending wrap" {
    var t = TerminalState.init(3, 4)
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    @assertEq(t.pending_wrap, true)
    t.setCursorPos(0, 0)
    @assertEq(t.pending_wrap, false)
}

// ============================================================================
// Tests — State: scroll region
// ============================================================================

test "setScrollingRegion" {
    var t = TerminalState.init(24, 80)
    t.cursor_row = 10
    t.cursor_col = 40
    t.setScrollingRegion(5, 20)
    @assertEq(t.scroll_top, 5)
    @assertEq(t.scroll_bottom, 20)
    // Cursor moves to origin after setting region
    @assertEq(t.cursor_row, 0)
    @assertEq(t.cursor_col, 0)
}

test "cursorUp respects scroll region" {
    var t = TerminalState.init(24, 80)
    t.setScrollingRegion(5, 20)
    t.setCursorPos(7, 0)
    t.cursorUp(100)
    @assertEq(t.cursor_row, 5)
}

// ============================================================================
// Tests — State: erase operations
// ============================================================================

test "eraseInDisplay all" {
    var t = TerminalState.init(3, 4)
    t.putChar('A')
    t.putChar('B')
    t.eraseInDisplay(2)
    @assert(t.grid.getCell(0, 0).isBlank())
    @assert(t.grid.getCell(0, 1).isBlank())
}

test "eraseInDisplay below" {
    var t = TerminalState.init(3, 4)
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    t.newline()
    t.carriageReturn()
    t.putChar('E')
    t.putChar('F')
    // Cursor at (1, 2), erase from cursor to end
    t.eraseInDisplay(0)
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(1, 0).codepoint, 'E')
    @assertEq(t.grid.getCell(1, 1).codepoint, 'F')
    @assert(t.grid.getCell(1, 2).isBlank())
    @assert(t.grid.getCell(2, 0).isBlank())
}

test "eraseInLine right" {
    var t = TerminalState.init(3, 4)
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    t.setCursorPos(0, 2)
    t.eraseInLine(0)
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(0, 1).codepoint, 'B')
    @assert(t.grid.getCell(0, 2).isBlank())
    @assert(t.grid.getCell(0, 3).isBlank())
}

test "eraseInLine left" {
    var t = TerminalState.init(3, 4)
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    t.setCursorPos(0, 2)
    t.eraseInLine(1)
    @assert(t.grid.getCell(0, 0).isBlank())
    @assert(t.grid.getCell(0, 1).isBlank())
    @assert(t.grid.getCell(0, 2).isBlank())
    @assertEq(t.grid.getCell(0, 3).codepoint, 'D')
}

// ============================================================================
// Tests — State: index / reverse index
// ============================================================================

test "index moves down" {
    var t = TerminalState.init(3, 4)
    t.cursor_row = 1
    t.index_()
    @assertEq(t.cursor_row, 2)
}

test "index at bottom scrolls" {
    var t = TerminalState.init(3, 4)
    t.cursor_row = 2
    t.grid.getCell(0, 0).codepoint = 'A'
    t.index_()
    @assertEq(t.cursor_row, 2)
    @assert(t.grid.getCell(0, 0).isBlank())
}

test "reverseIndex at top scrolls" {
    var t = TerminalState.init(3, 4)
    t.grid.getCell(0, 0).codepoint = 'A'
    t.reverseIndex()
    @assertEq(t.cursor_row, 0)
    @assertEq(t.grid.getCell(1, 0).codepoint, 'A')
}

// ============================================================================
// Tests — State: insert / delete
// ============================================================================

test "insertBlanks shifts cells right" {
    var t = TerminalState.init(3, 6)
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    t.setCursorPos(0, 1)
    t.insertBlanks(2)
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assert(t.grid.getCell(0, 1).isBlank())
    @assert(t.grid.getCell(0, 2).isBlank())
    @assertEq(t.grid.getCell(0, 3).codepoint, 'B')
    @assertEq(t.grid.getCell(0, 4).codepoint, 'C')
    @assertEq(t.grid.getCell(0, 5).codepoint, 'D')
}

test "deleteChars shifts cells left" {
    var t = TerminalState.init(3, 6)
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    t.putChar('E')
    t.putChar('F')
    t.setCursorPos(0, 1)
    t.deleteChars(2)
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(0, 1).codepoint, 'D')
    @assertEq(t.grid.getCell(0, 2).codepoint, 'E')
    @assertEq(t.grid.getCell(0, 3).codepoint, 'F')
    @assert(t.grid.getCell(0, 4).isBlank())
    @assert(t.grid.getCell(0, 5).isBlank())
}

// ============================================================================
// Tests — State: save/restore, attributes, resize
// ============================================================================

test "saveCursor restoreCursor" {
    var t = TerminalState.init(24, 80)
    t.setCursorPos(5, 10)
    t.saveCursor()
    t.setCursorPos(0, 0)
    t.restoreCursor()
    @assertEq(t.cursor_row, 5)
    @assertEq(t.cursor_col, 10)
}

test "resetAttributes restores defaults" {
    var t = TerminalState.init(3, 4)
    t.fg_r = 255
    t.fg_g = 0
    t.fg_b = 0
    t.bold = true
    t.resetAttributes()
    @assertEq(t.fg_r, t.default_fg_r)
    @assertEq(t.fg_g, t.default_fg_g)
    @assertEq(t.fg_b, t.default_fg_b)
    @assertEq(t.bold, false)
}

test "resize preserves content" {
    var t = TerminalState.init(3, 4)
    t.putChar('A')
    t.putChar('B')
    t.resize(5, 6)
    @assertEq(t.grid.rows, 5)
    @assertEq(t.grid.cols, 6)
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(0, 1).codepoint, 'B')
    @assertEq(t.scroll_bottom, 4)
}

test "resize shrink clamps cursor" {
    var t = TerminalState.init(24, 80)
    t.setCursorPos(20, 70)
    t.resize(10, 40)
    @assertEq(t.cursor_row, 9)
    @assertEq(t.cursor_col, 39)
    @assertEq(t.pending_wrap, false)
}

// ============================================================================
// Tests — Resize reflow
// ============================================================================

test "reflow shrink wraps long line" {
    // "ABCDEF" on a 6-col terminal, resize to 3 cols → 2 rows
    var t = TerminalState.init(3, 6)
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    t.putChar('E')
    t.putChar('F')
    t.resize(3, 3)
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(0, 1).codepoint, 'B')
    @assertEq(t.grid.getCell(0, 2).codepoint, 'C')
    @assertEq(t.grid.getCell(1, 0).codepoint, 'D')
    @assertEq(t.grid.getCell(1, 1).codepoint, 'E')
    @assertEq(t.grid.getCell(1, 2).codepoint, 'F')
    @assertEq(t.grid.getRowWrap(0), 1)
    @assertEq(t.grid.getRowWrap(1), 0)
}

test "reflow grow unwraps soft-wrapped line" {
    // Write 8 chars on a 4-col terminal (soft-wraps to 2 rows), widen to 8 cols
    var t = TerminalState.init(3, 4)
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    t.putChar('E')
    t.putChar('F')
    t.putChar('G')
    t.putChar('H')
    // Row 0: "ABCD" (wrap), Row 1: "EFGH"
    @assertEq(t.grid.getRowWrap(0), 1)

    t.resize(3, 8)
    // Should unwrap into one row: "ABCDEFGH"
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(0, 1).codepoint, 'B')
    @assertEq(t.grid.getCell(0, 2).codepoint, 'C')
    @assertEq(t.grid.getCell(0, 3).codepoint, 'D')
    @assertEq(t.grid.getCell(0, 4).codepoint, 'E')
    @assertEq(t.grid.getCell(0, 5).codepoint, 'F')
    @assertEq(t.grid.getCell(0, 6).codepoint, 'G')
    @assertEq(t.grid.getCell(0, 7).codepoint, 'H')
    @assertEq(t.grid.getRowWrap(0), 0)
}

test "reflow preserves hard newlines" {
    // Row 0: "AB" + LF, Row 1: "CD" — two logical lines
    var t = TerminalState.init(3, 4)
    t.putChar('A')
    t.putChar('B')
    t.newline()
    t.carriageReturn()
    t.putChar('C')
    t.putChar('D')
    @assertEq(t.grid.getRowWrap(0), 0)

    t.resize(3, 8)
    // Two separate logical lines, not joined
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(0, 1).codepoint, 'B')
    @assert(t.grid.getCell(0, 2).isBlank())
    @assertEq(t.grid.getCell(1, 0).codepoint, 'C')
    @assertEq(t.grid.getCell(1, 1).codepoint, 'D')
}

test "reflow cursor tracks through wrap" {
    // 6 chars on 6-col, cursor at col 5, resize to 3 cols
    var t = TerminalState.init(3, 6)
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    t.putChar('E')
    t.putChar('F')
    // cursor at (0, 5) with pending_wrap, but cursor_col is 5
    t.setCursorPos(0, 5)
    t.resize(3, 3)
    // cursor_abs = 5, 5/3 = 1, 5%3 = 2 → row 1, col 2
    @assertEq(t.cursor_row, 1)
    @assertEq(t.cursor_col, 2)
}

test "reflow rows only preserves wrap flags" {
    var t = TerminalState.init(3, 4)
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    t.putChar('E')
    // Row 0 soft-wraps into row 1
    @assertEq(t.grid.getRowWrap(0), 1)
    t.resize(5, 4)
    // Same cols → resizeRowsOnly path, wrap flag preserved
    @assertEq(t.grid.getRowWrap(0), 1)
    @assertEq(t.grid.getCell(0, 0).codepoint, 'A')
    @assertEq(t.grid.getCell(1, 0).codepoint, 'E')
}

test "scrollUp shifts wrap flags" {
    var g = TerminalGrid.init(3, 4)
    g.getCell(0, 0).codepoint = 'A'
    g.getCell(1, 0).codepoint = 'B'
    g.getCell(2, 0).codepoint = 'C'
    g.setRowWrap(0, 1)
    g.setRowWrap(1, 0)
    g.setRowWrap(2, 1)
    g.scrollUp(0, 2)
    @assertEq(g.getRowWrap(0), 0)
    @assertEq(g.getRowWrap(1), 1)
    @assertEq(g.getRowWrap(2), 0)
}

test "scrollDown shifts wrap flags" {
    var g = TerminalGrid.init(3, 4)
    g.getCell(0, 0).codepoint = 'A'
    g.getCell(1, 0).codepoint = 'B'
    g.getCell(2, 0).codepoint = 'C'
    g.setRowWrap(0, 1)
    g.setRowWrap(1, 0)
    g.setRowWrap(2, 1)
    g.scrollDown(0, 2)
    @assertEq(g.getRowWrap(0), 0)
    @assertEq(g.getRowWrap(1), 1)
    @assertEq(g.getRowWrap(2), 0)
}

// ============================================================================
// Tests — Selection
// ============================================================================

test "selection marks and clears flags" {
    var t = TerminalState.init(3, 4)
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    t.newline()
    t.carriageReturn()
    t.putChar('E')
    t.putChar('F')

    // Select from (0,1) to (0,3)
    t.selectionStart(0, 1)
    t.selectionUpdate(0, 3)
    @assertEq((t.grid.getCell(0, 0).flags & CELL_SELECTED), 0)
    @assertEq((t.grid.getCell(0, 1).flags & CELL_SELECTED), CELL_SELECTED)
    @assertEq((t.grid.getCell(0, 2).flags & CELL_SELECTED), CELL_SELECTED)
    @assertEq((t.grid.getCell(0, 3).flags & CELL_SELECTED), CELL_SELECTED)
    @assertEq((t.grid.getCell(1, 0).flags & CELL_SELECTED), 0)

    // Clear selection
    t.selectionClear()
    @assertEq((t.grid.getCell(0, 1).flags & CELL_SELECTED), 0)
    @assertEq((t.grid.getCell(0, 2).flags & CELL_SELECTED), 0)
    @assertEq(t.sel_active, false)
}

test "selection across rows and text extraction" {
    var t = TerminalState.init(3, 4)
    // Row 0: "ABCD"
    t.putChar('A')
    t.putChar('B')
    t.putChar('C')
    t.putChar('D')
    // Row 1: "EF"
    t.newline()
    t.carriageReturn()
    t.putChar('E')
    t.putChar('F')

    // Select from (0,2) to (1,1)
    t.selectionStart(0, 2)
    t.selectionUpdate(1, 1)

    // Row 0: cols 2-3 selected, Row 1: cols 0-1 selected
    @assertEq((t.grid.getCell(0, 0).flags & CELL_SELECTED), 0)
    @assertEq((t.grid.getCell(0, 1).flags & CELL_SELECTED), 0)
    @assertEq((t.grid.getCell(0, 2).flags & CELL_SELECTED), CELL_SELECTED)
    @assertEq((t.grid.getCell(0, 3).flags & CELL_SELECTED), CELL_SELECTED)
    @assertEq((t.grid.getCell(1, 0).flags & CELL_SELECTED), CELL_SELECTED)
    @assertEq((t.grid.getCell(1, 1).flags & CELL_SELECTED), CELL_SELECTED)
    @assertEq((t.grid.getCell(1, 2).flags & CELL_SELECTED), 0)

    // Extract text: "CD\nEF"
    var buf: List(u8) = undefined
    buf.items = 0
    buf.count = 0
    buf.capacity = 0
    var i: i64 = 0
    while (i < 64) {
        buf.append(0)
        i += 1
    }
    const len = t.writeSelectedText(buf.items, 64)
    @assertEq(len, 5)
    @assertEq(@intToPtr(*u8, buf.items + 0).*, 'C')
    @assertEq(@intToPtr(*u8, buf.items + 1).*, 'D')
    @assertEq(@intToPtr(*u8, buf.items + 2).*, '\n')
    @assertEq(@intToPtr(*u8, buf.items + 3).*, 'E')
    @assertEq(@intToPtr(*u8, buf.items + 4).*, 'F')
}
