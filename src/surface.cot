/// Surface: a single view — either a text editor or a terminal emulator.
/// Maps to Ghostty's Surface.zig.

import "std/os"
import "std/fs"
import "std/sys"
import "std/string"
import "std/thread"
import "buffer"
import "cursor"
import "input"
import "terminal"
import "vt_parser"
import "pty"
import "inspector"

// ============================================================================
// Pipe fd unpacking (same bit ops as pty.cot)
// ============================================================================

fn pipeReadFd(fds: i64) i64 {
    return fds & 4294967295
}

fn pipeWriteFd(fds: i64) i64 {
    return (fds >> 32) & 4294967295
}

// ============================================================================
// IO Reader Thread
// ============================================================================

/// Top-level function for the IO reader thread.
/// Reads from PTY fd in a blocking loop, feeds bytes through VT parser
/// under mutex, then signals main thread via notification pipe.
fn ioReaderMain(arg: i64) void {
    const surface = @intToPtr(*Surface, arg)
    const fd = surface.shell.master_fd
    var buf = alloc(0, 4096)
    defer dealloc(buf)
    while (true) {
        const n = fd_read(fd, buf, 4096)
        if (n <= 0) { break }
        surface.terminal_mutex.lock()
        var i: i64 = 0
        while (i < n) {
            const b = @intToPtr(*u8, buf + i).*
            surface.parser.feed(surface.terminal, b)
            i += 1
        }
        surface.terminal_mutex.unlock()
        // Notify main thread — content doesn't matter, just a signal
        fd_write(surface.notify_pipe_write, @ptrOf("!"), 1)
    }
}

// ============================================================================
// Surface Kind
// ============================================================================

const SurfaceKind = enum(u8) {
    Editor,
    Terminal,
}

/// A single surface (tab/window).
struct Surface {
    kind: SurfaceKind,
    buffer: Buffer,
    cursor: Cursor,
    scroll_offset: int,
    filepath: ?string,
    dirty: bool,
    terminal: TerminalState,
    parser: VtParser,
    shell: Pty,
    terminal_mutex: Mutex,
    io_thread: Thread,
    notify_pipe_read: i64,
    notify_pipe_write: i64,
    inspector: Inspector,

    /// Create an empty, untitled editor surface (heap-allocated with ARC).
    static fn init() *Surface {
        var dummy_mutex: Mutex = undefined
        dummy_mutex.ptr = 0
        var dummy_thread: Thread = undefined
        dummy_thread.handle = 0
        return new Surface {
            kind: SurfaceKind.Editor,
            buffer: Buffer.init(),
            cursor: Cursor.init(),
            scroll_offset: 0,
            filepath: null,
            dirty: false,
            terminal: TerminalState.init(0, 0),
            parser: VtParser.init(),
            shell: Pty { master_fd: -1, child_pid: -1 },
            terminal_mutex: dummy_mutex,
            io_thread: dummy_thread,
            notify_pipe_read: -1,
            notify_pipe_write: -1,
            inspector: Inspector.init(24, 80),
        }
    }

    /// Create an editor surface from a file path (heap-allocated with ARC).
    static fn initFromFile(path: string) *Surface {
        var dummy_mutex: Mutex = undefined
        dummy_mutex.ptr = 0
        var dummy_thread: Thread = undefined
        dummy_thread.handle = 0
        const content = readFile(path) catch {
            // File doesn't exist yet — create empty surface with path
            return new Surface {
                kind: SurfaceKind.Editor,
                buffer: Buffer.init(),
                cursor: Cursor.init(),
                scroll_offset: 0,
                filepath: path,
                dirty: false,
                terminal: TerminalState.init(0, 0),
                parser: VtParser.init(),
                shell: Pty { master_fd: -1, child_pid: -1 },
                terminal_mutex: dummy_mutex,
                io_thread: dummy_thread,
                notify_pipe_read: -1,
                notify_pipe_write: -1,
                inspector: Inspector.init(24, 80),
            }
        }

        return new Surface {
            kind: SurfaceKind.Editor,
            buffer: Buffer.initWithContent(content),
            cursor: Cursor.init(),
            scroll_offset: 0,
            filepath: path,
            dirty: false,
            terminal: TerminalState.init(0, 0),
            parser: VtParser.init(),
            shell: Pty { master_fd: -1, child_pid: -1 },
            terminal_mutex: dummy_mutex,
            io_thread: dummy_thread,
            notify_pipe_read: -1,
            notify_pipe_write: -1,
            inspector: Inspector.init(24, 80),
        }
    }

    /// Create a terminal surface with a shell spawned via Cot's PTY.
    /// Sets up IO reader thread: mutex, notification pipe, and spawns thread.
    /// Heap-allocated with ARC for pointer stability (IO thread holds raw pointer).
    static fn initTerminal(rows: i64, cols: i64) *Surface {
        const pty = Pty.spawn(rows, cols)
        var term = TerminalState.init(rows, cols)
        term.pty_fd = pty.master_fd

        // Create mutex to protect terminal state + parser
        var mtx = Mutex.init()

        // Create notification pipe for IO thread → main thread signaling
        const pipe_fds = pipe()
        const pipe_r = pipeReadFd(pipe_fds)
        const pipe_w = pipeWriteFd(pipe_fds)

        var dummy_thread: Thread = undefined
        dummy_thread.handle = 0

        return new Surface {
            kind: SurfaceKind.Terminal,
            buffer: Buffer.init(),
            cursor: Cursor.init(),
            scroll_offset: 0,
            filepath: null,
            dirty: false,
            terminal: term,
            parser: VtParser.init(),
            shell: pty,
            terminal_mutex: mtx,
            io_thread: dummy_thread,
            notify_pipe_read: pipe_r,
            notify_pipe_write: pipe_w,
            inspector: Inspector.init(rows, cols),
        }
    }

    /// Spawn the IO reader thread. Must be called after surface is at its
    /// final memory location (i.e., after being added to the surface list).
    fn startIoThread() void {
        self.io_thread = Thread.spawn(@ptrToInt(ioReaderMain), @ptrToInt(self))
    }

    /// Handle an input action, mutating buffer and cursor as needed.
    fn handleInput(action: InputAction, key: int) void {
        switch (action) {
            InputAction.insert_char => {
                self.buffer.moveGapTo(self.cursor.offset)
                self.buffer.insert(key)
                self.cursor.offset += 1
                self.cursor.col += 1
                if (key == '\n') {
                    self.cursor.line += 1
                    self.cursor.col = 0
                }
                self.dirty = true
            },
            InputAction.delete_back => {
                if (self.cursor.offset > 0) {
                    const deleted_char = self.buffer.charAt(self.cursor.offset - 1)
                    self.buffer.moveGapTo(self.cursor.offset)
                    self.buffer.deleteBack()
                    self.cursor.offset -= 1
                    if (deleted_char == '\n') {
                        self.recomputeLineCol()
                    } else {
                        self.cursor.col -= 1
                    }
                    self.dirty = true
                }
            },
            InputAction.delete_forward => {
                if (self.cursor.offset < self.buffer.len()) {
                    self.buffer.moveGapTo(self.cursor.offset)
                    self.buffer.deleteForward()
                    self.dirty = true
                }
            },
            InputAction.move_left => {
                if (self.cursor.offset > 0) {
                    self.cursor.offset -= 1
                    if (self.cursor.col > 0) {
                        self.cursor.col -= 1
                    } else {
                        self.recomputeLineCol()
                    }
                }
            },
            InputAction.move_right => {
                if (self.cursor.offset < self.buffer.len()) {
                    const ch = self.buffer.charAt(self.cursor.offset)
                    self.cursor.offset += 1
                    if (ch == '\n') {
                        self.cursor.line += 1
                        self.cursor.col = 0
                    } else {
                        self.cursor.col += 1
                    }
                }
            },
            InputAction.move_up => {
                if (self.cursor.line > 0) {
                    const target_col = self.cursor.col
                    self.cursor.line -= 1
                    const line_len = self.buffer.lineLength(self.cursor.line)
                    if (target_col < line_len) {
                        self.cursor.col = target_col
                    } else {
                        self.cursor.col = line_len
                    }
                    self.recomputeOffset()
                }
            },
            InputAction.move_down => {
                const total_lines = self.buffer.lineCount()
                if (self.cursor.line < total_lines - 1) {
                    const target_col = self.cursor.col
                    self.cursor.line += 1
                    const line_len = self.buffer.lineLength(self.cursor.line)
                    if (target_col < line_len) {
                        self.cursor.col = target_col
                    } else {
                        self.cursor.col = line_len
                    }
                    self.recomputeOffset()
                }
            },
            InputAction.move_line_start => {
                self.cursor.col = 0
                self.recomputeOffset()
            },
            InputAction.move_line_end => {
                self.cursor.col = self.buffer.lineLength(self.cursor.line)
                self.recomputeOffset()
            },
            else => {},
        }
    }

    /// Recompute line/col from byte offset by scanning from start.
    fn recomputeLineCol() void {
        var line = 0
        var col = 0
        for i in 0..self.cursor.offset {
            if (self.buffer.charAt(i) == '\n') {
                line += 1
                col = 0
            } else {
                col += 1
            }
        }
        self.cursor.line = line
        self.cursor.col = col
    }

    /// Recompute byte offset from line/col.
    fn recomputeOffset() void {
        self.cursor.offset = self.buffer.lineStartOffset(self.cursor.line) + self.cursor.col
    }

    /// Render the surface content to a string (for testing/debugging).
    fn render() string {
        return self.buffer.toString()
    }

    /// Returns true if this surface is a terminal emulator.
    fn isTerminal() bool {
        return self.kind == SurfaceKind.Terminal
    }

    /// Return the title for this surface.
    fn title() string {
        if (self.kind == SurfaceKind.Terminal) {
            return "terminal"
        }
        if (self.filepath) |path| {
            return path
        }
        return "untitled"
    }
}

// ============================================================================
// Tests
// ============================================================================

test "surface init empty" {
    var s = Surface.init()
    @assertEq(s.kind, SurfaceKind.Editor)
    @assertEq(s.buffer.len(), 0)
    @assertEq(s.cursor.line, 0)
    @assertEq(s.cursor.col, 0)
    @assertEq(s.dirty, false)
    @assertEq(s.title(), "untitled")
    @assert(!s.isTerminal())
}

test "surface handle insert" {
    var s = Surface.init()
    s.handleInput(InputAction.insert_char, 'h')
    s.handleInput(InputAction.insert_char, 'i')
    @assertEq(s.buffer.len(), 2)
    @assertEq(s.render(), "hi")
    @assertEq(s.dirty, true)
}

test "surface handle delete back" {
    var s = Surface.init()
    s.handleInput(InputAction.insert_char, 'a')
    s.handleInput(InputAction.insert_char, 'b')
    s.handleInput(InputAction.delete_back, 0)
    @assertEq(s.render(), "a")
}

test "surface handle move" {
    var s = Surface.init()
    s.handleInput(InputAction.insert_char, 'a')
    s.handleInput(InputAction.insert_char, 'b')
    @assertEq(s.cursor.offset, 2)
    s.handleInput(InputAction.move_left, 0)
    @assertEq(s.cursor.offset, 1)
    s.handleInput(InputAction.move_right, 0)
    @assertEq(s.cursor.offset, 2)
}

test "surface title with filepath" {
    var s = Surface.init()
    s.filepath = "test.cot"
    @assertEq(s.title(), "test.cot")
}

test "surface insert newline updates line col" {
    var s = Surface.init()
    s.handleInput(InputAction.insert_char, 'a')
    s.handleInput(InputAction.insert_char, 'b')
    s.handleInput(InputAction.insert_char, '\n')
    s.handleInput(InputAction.insert_char, 'c')
    @assertEq(s.cursor.line, 1)
    @assertEq(s.cursor.col, 1)
    @assertEq(s.cursor.offset, 4)
}

test "surface delete back newline recomputes" {
    var s = Surface.init()
    s.handleInput(InputAction.insert_char, 'a')
    s.handleInput(InputAction.insert_char, 'b')
    s.handleInput(InputAction.insert_char, '\n')
    s.handleInput(InputAction.insert_char, 'c')
    // cursor at line 1, col 1, offset 4
    // delete 'c' — stays on line 1
    s.handleInput(InputAction.delete_back, 0)
    @assertEq(s.cursor.line, 1)
    @assertEq(s.cursor.col, 0)
    @assertEq(s.cursor.offset, 3)
    // delete '\n' — recompute: back to line 0
    s.handleInput(InputAction.delete_back, 0)
    @assertEq(s.cursor.line, 0)
    @assertEq(s.cursor.col, 2)
    @assertEq(s.cursor.offset, 2)
}

test "surface move left across newline" {
    var s = Surface.init()
    s.handleInput(InputAction.insert_char, 'a')
    s.handleInput(InputAction.insert_char, '\n')
    s.handleInput(InputAction.insert_char, 'b')
    // cursor at line 1, col 1, offset 3
    s.handleInput(InputAction.move_left, 0)
    // now at line 1, col 0, offset 2
    @assertEq(s.cursor.line, 1)
    @assertEq(s.cursor.col, 0)
    @assertEq(s.cursor.offset, 2)
    // move left again — cross newline to line 0
    s.handleInput(InputAction.move_left, 0)
    @assertEq(s.cursor.line, 0)
    @assertEq(s.cursor.col, 1)
    @assertEq(s.cursor.offset, 1)
}

test "surface move right across newline" {
    var s = Surface.init()
    s.handleInput(InputAction.insert_char, 'a')
    s.handleInput(InputAction.insert_char, '\n')
    s.handleInput(InputAction.insert_char, 'b')
    // Go back to start
    s.cursor.offset = 0
    s.cursor.line = 0
    s.cursor.col = 0
    // move right: 'a' -> col 1
    s.handleInput(InputAction.move_right, 0)
    @assertEq(s.cursor.col, 1)
    @assertEq(s.cursor.offset, 1)
    // move right: '\n' -> line 1, col 0
    s.handleInput(InputAction.move_right, 0)
    @assertEq(s.cursor.line, 1)
    @assertEq(s.cursor.col, 0)
    @assertEq(s.cursor.offset, 2)
}

test "surface move up down clamps col" {
    var s = Surface.init()
    // "hello\nhi\nworld"
    s.handleInput(InputAction.insert_char, 'h')
    s.handleInput(InputAction.insert_char, 'e')
    s.handleInput(InputAction.insert_char, 'l')
    s.handleInput(InputAction.insert_char, 'l')
    s.handleInput(InputAction.insert_char, 'o')
    s.handleInput(InputAction.insert_char, '\n')
    s.handleInput(InputAction.insert_char, 'h')
    s.handleInput(InputAction.insert_char, 'i')
    s.handleInput(InputAction.insert_char, '\n')
    s.handleInput(InputAction.insert_char, 'w')
    s.handleInput(InputAction.insert_char, 'o')
    s.handleInput(InputAction.insert_char, 'r')
    s.handleInput(InputAction.insert_char, 'l')
    s.handleInput(InputAction.insert_char, 'd')
    // cursor at line 2, col 5, offset 14
    @assertEq(s.cursor.line, 2)
    @assertEq(s.cursor.col, 5)
    // move up — line 1 "hi" has len 2, clamp col to 2
    s.handleInput(InputAction.move_up, 0)
    @assertEq(s.cursor.line, 1)
    @assertEq(s.cursor.col, 2)
    @assertEq(s.cursor.offset, 8)
    // move up — line 0 "hello" has len 5, col stays 2
    s.handleInput(InputAction.move_up, 0)
    @assertEq(s.cursor.line, 0)
    @assertEq(s.cursor.col, 2)
    @assertEq(s.cursor.offset, 2)
}

test "surface move line end" {
    var s = Surface.init()
    s.handleInput(InputAction.insert_char, 'h')
    s.handleInput(InputAction.insert_char, 'e')
    s.handleInput(InputAction.insert_char, 'l')
    s.handleInput(InputAction.insert_char, 'l')
    s.handleInput(InputAction.insert_char, 'o')
    s.handleInput(InputAction.insert_char, '\n')
    s.handleInput(InputAction.insert_char, 'h')
    s.handleInput(InputAction.insert_char, 'i')
    // cursor at line 1, col 2
    // move to line start
    s.handleInput(InputAction.move_line_start, 0)
    @assertEq(s.cursor.col, 0)
    @assertEq(s.cursor.offset, 6)
    // move to line end
    s.handleInput(InputAction.move_line_end, 0)
    @assertEq(s.cursor.col, 2)
    @assertEq(s.cursor.offset, 8)
}

test "surface move down from last line no-op" {
    var s = Surface.init()
    s.handleInput(InputAction.insert_char, 'a')
    @assertEq(s.cursor.line, 0)
    s.handleInput(InputAction.move_down, 0)
    @assertEq(s.cursor.line, 0)
}

test "terminal surface kind" {
    var s = Surface.initTerminal(24, 80)
    @assertEq(s.kind, SurfaceKind.Terminal)
    @assert(s.isTerminal())
    @assertEq(s.title(), "terminal")
    @assertEq(s.terminal.grid.rows, 24)
    @assertEq(s.terminal.grid.cols, 80)
    s.shell.close()
    fd_close(s.notify_pipe_read)
    fd_close(s.notify_pipe_write)
    s.terminal_mutex.destroy()
}

test "editor surface has inactive terminal" {
    var s = Surface.init()
    @assertEq(s.kind, SurfaceKind.Editor)
    @assertEq(s.terminal.grid.rows, 0)
    @assertEq(s.terminal.grid.cols, 0)
    @assertEq(s.shell.master_fd, -1)
}
