/// Gap buffer for text storage.
/// Maps conceptually to Ghostty's terminal data (the core data structure)
/// and Zed's rope, but using a simpler gap buffer approach.
///
/// A gap buffer stores text with a "gap" (unused space) that moves to the
/// cursor position. Insertions and deletions at the gap are O(1), and
/// moving the gap is O(n) where n is the distance moved. This makes it
/// efficient for the typical editing pattern of sequential local edits.

import "std/list"
import "std/string"

/// Initial gap size when creating a new buffer.
const INITIAL_GAP_SIZE: int = 64

/// Gap buffer: contiguous byte array with a movable gap.
struct Buffer {
    data: List(u8),
    gap_start: int,
    gap_end: int,
}

impl Buffer {
    /// Create an empty buffer with an initial gap.
    static fn init() Buffer {
        var data: List(u8) = undefined
        data.items = 0
        data.count = 0
        data.capacity = 0

        // Pre-allocate gap
        var i = 0
        while (i < INITIAL_GAP_SIZE) {
            data.append(0)
            i += 1
        }

        return Buffer {
            data: data,
            gap_start: 0,
            gap_end: INITIAL_GAP_SIZE,
        }
    }

    /// Create a buffer initialized with content.
    static fn initWithContent(content: string) Buffer {
        var buf = Buffer.init()
        var i = 0
        const content_len = @lenOf(content)
        while (i < content_len) {
            buf.insert(charAt(content, i))
            i += 1
        }
        return buf
    }

    /// Number of actual characters in the buffer (excluding the gap).
    fn len() int {
        return self.data.count - (self.gap_end - self.gap_start)
    }

    /// Size of the current gap.
    fn gapSize() int {
        return self.gap_end - self.gap_start
    }

    /// Insert a byte at the current gap position.
    fn insert(ch: int) void {
        if (self.gap_start == self.gap_end) {
            self.growGap()
        }
        self.data.set(self.gap_start, @intCast(u8, ch))
        self.gap_start += 1
    }

    /// Delete one byte before the gap (backspace).
    fn deleteBack() void {
        if (self.gap_start > 0) {
            self.gap_start -= 1
        }
    }

    /// Delete one byte after the gap (delete key).
    fn deleteForward() void {
        if (self.gap_end < self.data.count) {
            self.gap_end += 1
        }
    }

    /// Move the gap to a specific position in the logical text.
    fn moveGapTo(pos: int) void {
        if (pos == self.gap_start) { return }

        if (pos < self.gap_start) {
            // Move gap left: shift bytes from [pos, gap_start) to after gap
            const shift = self.gap_start - pos
            var i = 0
            while (i < shift) {
                self.data.set(self.gap_end - shift + i, self.data.get(pos + i))
                i += 1
            }
            self.gap_start = pos
            self.gap_end -= shift
        } else {
            // Move gap right: shift bytes from [gap_end, gap_end + (pos - gap_start)) to before gap
            const shift = pos - self.gap_start
            var i = 0
            while (i < shift) {
                self.data.set(self.gap_start + i, self.data.get(self.gap_end + i))
                i += 1
            }
            self.gap_start += shift
            self.gap_end += shift
        }
    }

    /// Get the byte at a logical position (accounting for the gap).
    fn charAt(pos: int) int {
        if (pos < self.gap_start) {
            return self.data.get(pos)
        }
        return self.data.get(pos + self.gapSize())
    }

    /// Count the number of newline characters in the buffer.
    fn lineCount() int {
        var count = 1
        var i = 0
        const text_len = self.len()
        while (i < text_len) {
            if (self.charAt(i) == '\n') {
                count += 1
            }
            i += 1
        }
        return count
    }

    /// Get the content of a specific line (0-indexed). Returns the line without newline.
    fn lineAt(line_num: int) string {
        var current_line = 0
        var line_start = 0
        var i = 0
        const text_len = self.len()

        // Find the start of the requested line
        while (i < text_len and current_line < line_num) {
            if (self.charAt(i) == '\n') {
                current_line += 1
                line_start = i + 1
            }
            i += 1
        }

        if (current_line != line_num) {
            return ""
        }

        // Find the end of the line
        var line_end = line_start
        while (line_end < text_len) {
            if (self.charAt(line_end) == '\n') { break }
            line_end += 1
        }

        // Build the line string
        var result: List(u8) = undefined
        result.items = 0
        result.count = 0
        result.capacity = 0
        var j = line_start
        while (j < line_end) {
            result.append(@intCast(u8, self.charAt(j)))
            j += 1
        }
        return @string(result.items, result.count)
    }

    /// Convert the entire buffer to a string.
    fn toString() string {
        var result: List(u8) = undefined
        result.items = 0
        result.count = 0
        result.capacity = 0
        var i = 0
        const text_len = self.len()
        while (i < text_len) {
            result.append(@intCast(u8, self.charAt(i)))
            i += 1
        }
        return @string(result.items, result.count)
    }

    /// Get the length of a specific line (0-indexed), not including newline.
    fn lineLength(line_num: int) int {
        var current_line = 0
        var line_start = 0
        var i = 0
        const text_len = self.len()
        while (i < text_len and current_line < line_num) {
            if (self.charAt(i) == '\n') {
                current_line += 1
                line_start = i + 1
            }
            i += 1
        }
        if (current_line != line_num) { return 0 }
        var line_end = line_start
        while (line_end < text_len) {
            if (self.charAt(line_end) == '\n') { break }
            line_end += 1
        }
        return line_end - line_start
    }

    /// Get the byte offset of the start of a specific line (0-indexed).
    fn lineStartOffset(line_num: int) int {
        if (line_num == 0) { return 0 }
        var current_line = 0
        var i = 0
        const text_len = self.len()
        while (i < text_len) {
            if (self.charAt(i) == '\n') {
                current_line += 1
                if (current_line == line_num) { return i + 1 }
            }
            i += 1
        }
        return self.len()
    }

    /// Grow the gap when it's full. Doubles the gap size.
    fn growGap() void {
        const old_gap_size = self.gapSize()
        var new_gap_size = INITIAL_GAP_SIZE
        if (old_gap_size > 0) {
            new_gap_size = old_gap_size * 2
        }

        // Insert new_gap_size bytes at gap_end
        var i = 0
        while (i < new_gap_size) {
            // Append a zero byte to extend the list
            self.data.append(0)
            i += 1
        }

        // Shift bytes after the gap to make room
        const bytes_after_gap = self.data.count - new_gap_size - self.gap_end
        if (bytes_after_gap > 0) {
            var j = bytes_after_gap - 1
            while (j >= 0) {
                self.data.set(self.gap_end + new_gap_size + j, self.data.get(self.gap_end + j))
                if (j == 0) { break }
                j -= 1
            }
        }

        self.gap_end += new_gap_size
    }
}

// ============================================================================
// Tests
// ============================================================================

test "buffer init empty" {
    var buf = Buffer.init()
    @assertEq(buf.len(), 0)
    @assertEq(buf.lineCount(), 1)
}

test "buffer insert single char" {
    var buf = Buffer.init()
    buf.insert('a')
    @assertEq(buf.len(), 1)
    @assertEq(buf.charAt(0), 'a')
}

test "buffer insert multiple chars" {
    var buf = Buffer.init()
    buf.insert('h')
    buf.insert('i')
    @assertEq(buf.len(), 2)
    @assertEq(buf.charAt(0), 'h')
    @assertEq(buf.charAt(1), 'i')
}

test "buffer delete back" {
    var buf = Buffer.init()
    buf.insert('a')
    buf.insert('b')
    buf.insert('c')
    buf.deleteBack()
    @assertEq(buf.len(), 2)
    @assertEq(buf.toString(), "ab")
}

test "buffer delete back at start" {
    var buf = Buffer.init()
    buf.deleteBack()
    @assertEq(buf.len(), 0)
}

test "buffer delete forward" {
    var buf = Buffer.init()
    buf.insert('a')
    buf.insert('b')
    buf.insert('c')
    buf.moveGapTo(1)
    buf.deleteForward()
    @assertEq(buf.len(), 2)
    @assertEq(buf.toString(), "ac")
}

test "buffer move gap" {
    var buf = Buffer.init()
    buf.insert('a')
    buf.insert('b')
    buf.insert('c')
    buf.moveGapTo(1)
    buf.insert('x')
    @assertEq(buf.toString(), "axbc")
}

test "buffer line count single line" {
    var buf = Buffer.initWithContent("hello")
    @assertEq(buf.lineCount(), 1)
}

test "buffer line count multiple lines" {
    var buf = Buffer.initWithContent("hello\nworld\nfoo")
    @assertEq(buf.lineCount(), 3)
}

test "buffer line at" {
    var buf = Buffer.initWithContent("hello\nworld\nfoo")
    @assertEq(buf.lineAt(0), "hello")
    @assertEq(buf.lineAt(1), "world")
    @assertEq(buf.lineAt(2), "foo")
}

test "buffer line at out of range" {
    var buf = Buffer.initWithContent("hello")
    @assertEq(buf.lineAt(1), "")
}

test "buffer to string" {
    var buf = Buffer.initWithContent("hello world")
    @assertEq(buf.toString(), "hello world")
}

test "buffer to string empty" {
    var buf = Buffer.init()
    @assertEq(buf.toString(), "")
}

test "buffer init with content" {
    var buf = Buffer.initWithContent("abc")
    @assertEq(buf.len(), 3)
    @assertEq(buf.charAt(0), 'a')
    @assertEq(buf.charAt(1), 'b')
    @assertEq(buf.charAt(2), 'c')
}

test "buffer insert at middle" {
    var buf = Buffer.initWithContent("ac")
    buf.moveGapTo(1)
    buf.insert('b')
    @assertEq(buf.toString(), "abc")
}

test "buffer insert at beginning" {
    var buf = Buffer.initWithContent("bc")
    buf.moveGapTo(0)
    buf.insert('a')
    @assertEq(buf.toString(), "abc")
}

test "buffer line length single line" {
    var buf = Buffer.initWithContent("hello")
    @assertEq(buf.lineLength(0), 5)
}

test "buffer line length multi line" {
    var buf = Buffer.initWithContent("hello\nworld\nfoo")
    @assertEq(buf.lineLength(0), 5)
    @assertEq(buf.lineLength(1), 5)
    @assertEq(buf.lineLength(2), 3)
}

test "buffer line length empty line" {
    var buf = Buffer.initWithContent("hello\n\nworld")
    @assertEq(buf.lineLength(0), 5)
    @assertEq(buf.lineLength(1), 0)
    @assertEq(buf.lineLength(2), 5)
}

test "buffer line length out of range" {
    var buf = Buffer.initWithContent("hello")
    @assertEq(buf.lineLength(5), 0)
}

test "buffer line start offset" {
    var buf = Buffer.initWithContent("hello\nworld\nfoo")
    @assertEq(buf.lineStartOffset(0), 0)
    @assertEq(buf.lineStartOffset(1), 6)
    @assertEq(buf.lineStartOffset(2), 12)
}

test "buffer line start offset empty lines" {
    var buf = Buffer.initWithContent("a\n\nb")
    @assertEq(buf.lineStartOffset(0), 0)
    @assertEq(buf.lineStartOffset(1), 2)
    @assertEq(buf.lineStartOffset(2), 3)
}

test "buffer line start offset past end" {
    var buf = Buffer.initWithContent("hello")
    @assertEq(buf.lineStartOffset(5), 5)
}
