/// FFI export layer for libcotty.dylib.
/// Ghostty-style opaque handles: cotty_app_t (pointer) and cotty_surface_t (index).
/// Action queue for Cot→Swift communication (poll-drain model).

import "app"
import "surface"
import "buffer"
import "cursor"
import "input"
import "message"
import "terminal"
import "cell"
import "vt_parser"
import "pty"
import "config"

// ============================================================================
// Globals
// ============================================================================

var g_app: App = undefined

/// Action queue — one pending action, read by Swift after each call.
var g_action_tag: i64 = 0
var g_action_payload: i64 = 0
var g_action_surface: i64 = -1

const ACTION_NONE: i64 = 0
const ACTION_QUIT: i64 = 1
const ACTION_NEW_WINDOW: i64 = 2
const ACTION_CLOSE_SURFACE: i64 = 3
const ACTION_MARK_DIRTY: i64 = 4

// ============================================================================
// Helpers
// ============================================================================

/// Get a mutable pointer to a surface in the list by index.
/// Same pointer math as List.get() but returns *Surface instead of copying.
fn getSurfacePtr(idx: i64) *Surface {
    return @intToPtr(*Surface, g_app.surfaces.items + idx * @sizeOf(Surface))
}

// ============================================================================
// App lifecycle
// ============================================================================

/// Create and initialize the global app. Returns opaque app handle.
export fn cotty_app_new() i64 {
    g_app = App.init()
    const path = configPath()
    if (@lenOf(path) > 0) {
        g_app.config = Config.loadFromFile(path)
    }
    initThemeDefaults(g_app.config)
    return @ptrToInt(&g_app)
}

/// Destroy the global app.
export fn cotty_app_free(app: i64) void {
    g_app.surfaces.free()
    g_app.mailbox.free()
}

/// Run one tick — drains the mailbox.
export fn cotty_app_tick(app: i64) void {
    g_app.tick()
}

/// Return the number of open surfaces.
export fn cotty_app_surface_count(app: i64) i64 {
    return g_app.surfaces.count
}

/// Return 1 if the app is still running, 0 otherwise.
export fn cotty_app_is_running(app: i64) i64 {
    if (g_app.running) {
        return 1
    }
    return 0
}

// ============================================================================
// Action queue
// ============================================================================

/// Read and clear the pending action tag. Returns ACTION_NONE if empty.
export fn cotty_app_next_action(app: i64) i64 {
    const tag = g_action_tag
    g_action_tag = ACTION_NONE
    return tag
}

/// Read the payload of the last consumed action.
export fn cotty_app_action_payload(app: i64) i64 {
    return g_action_payload
}

/// Read the surface index of the last consumed action (-1 if none).
export fn cotty_app_action_surface(app: i64) i64 {
    return g_action_surface
}

// ============================================================================
// Surface lifecycle
// ============================================================================

/// Create a new empty surface. Returns its index (the surface handle).
export fn cotty_surface_new(app: i64) i64 {
    return g_app.addSurface()
}

/// Remove a surface by index.
export fn cotty_surface_free(surface: i64) void {
    g_app.removeSurface(surface)
}

// ============================================================================
// Surface input
// ============================================================================

/// Send a key event to a surface. Routes through keyToAction dispatch.
export fn cotty_surface_key(surface: i64, key: i64, mods: i64) void {
    const event = KeyEvent { key: key, mods: mods }
    const action = keyToAction(event)

    const ptr = getSurfacePtr(surface)

    switch (action) {
        InputAction.insert_char => {
            // Tab → 4 spaces
            if (key == 9) {
                ptr.handleInput(InputAction.insert_char, ' ')
                ptr.handleInput(InputAction.insert_char, ' ')
                ptr.handleInput(InputAction.insert_char, ' ')
                ptr.handleInput(InputAction.insert_char, ' ')
            } else if (key == 13) {
                // Enter → newline
                ptr.handleInput(InputAction.insert_char, '\n')
            } else {
                ptr.handleInput(InputAction.insert_char, key)
            }
            g_action_tag = ACTION_MARK_DIRTY
            g_action_surface = surface
        },
        InputAction.delete_back => {
            ptr.handleInput(InputAction.delete_back, 0)
            g_action_tag = ACTION_MARK_DIRTY
            g_action_surface = surface
        },
        InputAction.delete_forward => {
            ptr.handleInput(InputAction.delete_forward, 0)
            g_action_tag = ACTION_MARK_DIRTY
            g_action_surface = surface
        },
        InputAction.move_left => {
            ptr.handleInput(InputAction.move_left, 0)
        },
        InputAction.move_right => {
            ptr.handleInput(InputAction.move_right, 0)
        },
        InputAction.move_up => {
            ptr.handleInput(InputAction.move_up, 0)
        },
        InputAction.move_down => {
            ptr.handleInput(InputAction.move_down, 0)
        },
        InputAction.move_line_start => {
            ptr.handleInput(InputAction.move_line_start, 0)
        },
        InputAction.move_line_end => {
            ptr.handleInput(InputAction.move_line_end, 0)
        },
        InputAction.page_up => {
            ptr.handleInput(InputAction.page_up, 0)
        },
        InputAction.page_down => {
            ptr.handleInput(InputAction.page_down, 0)
        },
        InputAction.save => {
            g_action_tag = ACTION_MARK_DIRTY
            g_action_surface = surface
        },
        InputAction.quit => {
            g_app.postMessage(Message.quit)
            g_action_tag = ACTION_QUIT
        },
        InputAction.new_surface => {
            g_action_tag = ACTION_NEW_WINDOW
        },
        InputAction.close_surface => {
            g_action_tag = ACTION_CLOSE_SURFACE
            g_action_surface = surface
        },
        else => {},
    }
}

/// Insert raw UTF-8 bytes into a surface.
export fn cotty_surface_text(surface: i64, ptr: *u8, len: i64) void {
    const sptr = getSurfacePtr(surface)
    var i: i64 = 0
    while (i < len) {
        const byte_ptr = @intToPtr(*u8, @ptrToInt(ptr) + i)
        sptr.handleInput(InputAction.insert_char, byte_ptr.*)
        i += 1
    }
    g_action_tag = ACTION_MARK_DIRTY
    g_action_surface = surface
}

/// Load content into a surface, replacing existing buffer.
export fn cotty_surface_load_content(surface: i64, ptr: *u8, len: i64) void {
    const sptr = getSurfacePtr(surface)
    // Reset surface to empty
    sptr.buffer = Buffer.init()
    sptr.cursor = Cursor.init()
    sptr.dirty = false
    // Insert content byte by byte
    var i: i64 = 0
    while (i < len) {
        const byte_ptr = @intToPtr(*u8, @ptrToInt(ptr) + i)
        sptr.handleInput(InputAction.insert_char, byte_ptr.*)
        i += 1
    }
    // Reset cursor to start
    sptr.cursor.offset = 0
    sptr.cursor.line = 0
    sptr.cursor.col = 0
    sptr.dirty = false
}

// ============================================================================
// Surface queries
// ============================================================================

export fn cotty_surface_buffer_len(surface: i64) i64 {
    return getSurfacePtr(surface).buffer.len()
}

export fn cotty_surface_buffer_line_count(surface: i64) i64 {
    return getSurfacePtr(surface).buffer.lineCount()
}

export fn cotty_surface_buffer_line_length(surface: i64, line: i64) i64 {
    return getSurfacePtr(surface).buffer.lineLength(line)
}

export fn cotty_surface_buffer_line_start_offset(surface: i64, line: i64) i64 {
    return getSurfacePtr(surface).buffer.lineStartOffset(line)
}

export fn cotty_surface_buffer_char_at(surface: i64, pos: i64) i64 {
    return getSurfacePtr(surface).buffer.charAt(pos)
}

export fn cotty_surface_cursor_line(surface: i64) i64 {
    return getSurfacePtr(surface).cursor.line
}

export fn cotty_surface_cursor_col(surface: i64) i64 {
    return getSurfacePtr(surface).cursor.col
}

export fn cotty_surface_cursor_offset(surface: i64) i64 {
    return getSurfacePtr(surface).cursor.offset
}

export fn cotty_surface_is_dirty(surface: i64) i64 {
    if (getSurfacePtr(surface).dirty) {
        return 1
    }
    return 0
}

export fn cotty_surface_set_clean(surface: i64) void {
    getSurfacePtr(surface).dirty = false
}

// ============================================================================
// Surface kind
// ============================================================================

/// Return the surface kind: 0 = editor, 1 = terminal.
export fn cotty_surface_kind(surface: i64) i64 {
    return getSurfacePtr(surface).kind
}

// ============================================================================
// Terminal surface lifecycle
// ============================================================================

/// Create a new terminal surface with a shell. Returns its index.
export fn cotty_terminal_surface_new(app: i64, rows: i64, cols: i64) i64 {
    return g_app.addTerminalSurface(rows, cols)
}

/// Close the PTY and remove a terminal surface.
export fn cotty_terminal_surface_free(surface: i64) void {
    getSurfacePtr(surface).shell.close()
    g_app.removeSurface(surface)
}

// ============================================================================
// Terminal I/O
// ============================================================================

/// Send a key event to a terminal surface.
/// Translates abstract KEY_* constant + mods to VT100 bytes and writes to PTY.
export fn cotty_terminal_key(surface: i64, key: i64, mods: i64) void {
    const sptr = getSurfacePtr(surface)
    keyToTerminalBytes(sptr.shell.master_fd, key, mods, sptr.terminal.mode_app_cursor)
}

/// Write raw bytes to the terminal's PTY (sends input to the shell).
export fn cotty_terminal_write(surface: i64, ptr: *u8, len: i64) void {
    const sptr = getSurfacePtr(surface)
    fd_write(sptr.shell.master_fd, @ptrToInt(ptr), len)
}

/// Read available bytes from the terminal's PTY into buf.
/// Returns bytes read, 0 on EOF, negative on error/EAGAIN.
export fn cotty_terminal_read(surface: i64, ptr: *u8, len: i64) i64 {
    const sptr = getSurfacePtr(surface)
    return fd_read(sptr.shell.master_fd, @ptrToInt(ptr), len)
}

/// Resize the terminal grid and PTY to new dimensions.
export fn cotty_terminal_resize(surface: i64, rows: i64, cols: i64) void {
    const sptr = getSurfacePtr(surface)
    sptr.terminal.resize(rows, cols)
    sptr.shell.resize(rows, cols)
}

/// Feed raw bytes through the VT parser into the terminal state.
/// Call this after cotty_terminal_read to process shell output.
export fn cotty_terminal_feed(surface: i64, ptr: *u8, len: i64) void {
    const sptr = getSurfacePtr(surface)
    var i: i64 = 0
    while (i < len) {
        const b = @intToPtr(*u8, @ptrToInt(ptr) + i).*
        sptr.parser.feed(sptr.terminal, b)
        i += 1
    }
}

/// Feed a single byte through the VT parser.
/// Avoids Cot-side loop that triggers *Cell heap corruption.
export fn cotty_terminal_feed_byte(surface: i64, b: i64) void {
    const sptr = getSurfacePtr(surface)
    sptr.parser.feed(sptr.terminal, b)
}

// ============================================================================
// Terminal grid queries
// ============================================================================

/// Return the number of rows in the terminal grid.
export fn cotty_terminal_rows(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.grid.rows
}

/// Return the number of columns in the terminal grid.
export fn cotty_terminal_cols(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.grid.cols
}

/// Return the codepoint of the cell at (row, col).
export fn cotty_terminal_cell_codepoint(surface: i64, row: i64, col: i64) i64 {
    return getSurfacePtr(surface).terminal.grid.getCell(row, col).codepoint
}

/// Return the foreground color of the cell at (row, col) as packed RGB.
/// Format: (r << 16) | (g << 8) | b
export fn cotty_terminal_cell_fg(surface: i64, row: i64, col: i64) i64 {
    const c = getSurfacePtr(surface).terminal.grid.getCell(row, col)
    return (c.fg_r << 16) | (c.fg_g << 8) | c.fg_b
}

/// Return the background color of the cell at (row, col) as packed RGB.
/// Format: (r << 16) | (g << 8) | b
export fn cotty_terminal_cell_bg(surface: i64, row: i64, col: i64) i64 {
    const c = getSurfacePtr(surface).terminal.grid.getCell(row, col)
    return (c.bg_r << 16) | (c.bg_g << 8) | c.bg_b
}

/// Return the flags of the cell at (row, col).
export fn cotty_terminal_cell_flags(surface: i64, row: i64, col: i64) i64 {
    return getSurfacePtr(surface).terminal.grid.getCell(row, col).flags
}

// ============================================================================
// Terminal cursor queries
// ============================================================================

/// Return the terminal cursor row.
export fn cotty_terminal_cursor_row(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.cursor_row
}

/// Return the terminal cursor column.
export fn cotty_terminal_cursor_col(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.cursor_col
}

/// Return 1 if the terminal cursor is visible, 0 otherwise.
export fn cotty_terminal_cursor_visible(surface: i64) i64 {
    if (getSurfacePtr(surface).terminal.cursor_visible) {
        return 1
    }
    return 0
}

/// Return the PTY master fd (for polling with kqueue/epoll).
export fn cotty_terminal_pty_fd(surface: i64) i64 {
    return getSurfacePtr(surface).shell.master_fd
}

/// Return the child PID of the terminal's shell process.
export fn cotty_terminal_child_pid(surface: i64) i64 {
    return getSurfacePtr(surface).shell.child_pid
}

/// Return a pointer to the raw cells buffer for direct access from Swift.
/// Each cell is 8 contiguous i64 fields: codepoint, fg_r, fg_g, fg_b, bg_r, bg_g, bg_b, flags.
/// Stride per cell = 8 * 8 = 64 bytes. Total cells = rows * cols.
export fn cotty_terminal_cells_ptr(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.grid.cells.items
}

// ============================================================================
// Terminal selection
// ============================================================================

/// Selected text buffer — allocated on first use.
var g_sel_buf: i64 = 0
var g_sel_buf_cap: i64 = 0
var g_sel_len: i64 = 0

/// Begin a selection at (row, col).
export fn cotty_terminal_selection_start(surface: i64, row: i64, col: i64) void {
    getSurfacePtr(surface).terminal.selectionStart(row, col)
}

/// Update selection endpoint to (row, col).
export fn cotty_terminal_selection_update(surface: i64, row: i64, col: i64) void {
    getSurfacePtr(surface).terminal.selectionUpdate(row, col)
}

/// Clear the selection.
export fn cotty_terminal_selection_clear(surface: i64) void {
    getSurfacePtr(surface).terminal.selectionClear()
}

/// Return 1 if a selection is active, 0 otherwise.
export fn cotty_terminal_selection_active(surface: i64) i64 {
    if (getSurfacePtr(surface).terminal.sel_active) {
        return 1
    }
    return 0
}

/// Extract selected text into an internal buffer and return the pointer.
/// Call cotty_terminal_selected_text_len to get the byte count.
export fn cotty_terminal_selected_text(surface: i64) i64 {
    // Ensure buffer allocated (64KB)
    if (g_sel_buf == 0) {
        g_sel_buf_cap = 65536
        g_sel_buf = alloc(0, g_sel_buf_cap)
    }
    g_sel_len = getSurfacePtr(surface).terminal.writeSelectedText(g_sel_buf, g_sel_buf_cap)
    return g_sel_buf
}

/// Return the byte length of the last extracted selected text.
export fn cotty_terminal_selected_text_len(surface: i64) i64 {
    return g_sel_len
}

// ============================================================================
// Config accessors
// ============================================================================

/// Return a pointer to the font name string bytes.
export fn cotty_config_font_name() i64 {
    return @ptrOf(g_app.config.font_name)
}

/// Return the byte length of the font name string.
export fn cotty_config_font_name_len() i64 {
    return @lenOf(g_app.config.font_name)
}

/// Return the configured font size.
export fn cotty_config_font_size() i64 {
    return g_app.config.font_size
}

/// Return the configured padding in points.
export fn cotty_config_padding() i64 {
    return g_app.config.padding
}

/// Return the background color red component.
export fn cotty_config_bg_r() i64 {
    return g_app.config.bg_r
}

/// Return the background color green component.
export fn cotty_config_bg_g() i64 {
    return g_app.config.bg_g
}

/// Return the background color blue component.
export fn cotty_config_bg_b() i64 {
    return g_app.config.bg_b
}

/// Return the foreground color red component.
export fn cotty_config_fg_r() i64 {
    return g_app.config.fg_r
}

/// Return the foreground color green component.
export fn cotty_config_fg_g() i64 {
    return g_app.config.fg_g
}

/// Return the foreground color blue component.
export fn cotty_config_fg_b() i64 {
    return g_app.config.fg_b
}

/// Return the cursor color red component.
export fn cotty_config_cursor_r() i64 {
    return g_app.config.cursor_r
}

/// Return the cursor color green component.
export fn cotty_config_cursor_g() i64 {
    return g_app.config.cursor_g
}

/// Return the cursor color blue component.
export fn cotty_config_cursor_b() i64 {
    return g_app.config.cursor_b
}

/// Return the selection background red component.
export fn cotty_config_sel_bg_r() i64 {
    return g_app.config.sel_bg_r
}

/// Return the selection background green component.
export fn cotty_config_sel_bg_g() i64 {
    return g_app.config.sel_bg_g
}

/// Return the selection background blue component.
export fn cotty_config_sel_bg_b() i64 {
    return g_app.config.sel_bg_b
}

/// Return the selection foreground red component.
export fn cotty_config_sel_fg_r() i64 {
    return g_app.config.sel_fg_r
}

/// Return the selection foreground green component.
export fn cotty_config_sel_fg_g() i64 {
    return g_app.config.sel_fg_g
}

/// Return the selection foreground blue component.
export fn cotty_config_sel_fg_b() i64 {
    return g_app.config.sel_fg_b
}

