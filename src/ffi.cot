/// FFI export layer for libcotty.dylib.
/// Ghostty-style opaque handles: cotty_app_t and cotty_surface_t are both pointers.
/// Action queue for Cot→Swift communication (poll-drain model).

import "std/sys"
import "app"
import "surface"
import "buffer"
import "cursor"
import "input"
import "message"
import "terminal"
import "cell"
import "vt_parser"
import "pty"
import "config"
import "inspector"

// ============================================================================
// Globals
// ============================================================================

var g_app: App = undefined

/// Action queue — one pending action, read by Swift after each call.
var g_action_tag: i64 = 0
var g_action_payload: i64 = 0
var g_action_surface: i64 = 0

const ACTION_NONE: i64 = 0
const ACTION_QUIT: i64 = 1
const ACTION_NEW_WINDOW: i64 = 2
const ACTION_CLOSE_SURFACE: i64 = 3
const ACTION_MARK_DIRTY: i64 = 4

// ============================================================================
// Helpers
// ============================================================================

/// Cast an opaque surface handle to a *Surface pointer.
/// Handles are stable pointers to heap-allocated Surfaces (Ghostty pattern).
fn getSurfacePtr(handle: i64) *Surface {
    return @intToPtr(*Surface, handle)
}

// ============================================================================
// App lifecycle
// ============================================================================

/// Create and initialize the global app. Returns opaque app handle.
export fn cotty_app_new() i64 {
    g_app = App.init()
    const path = configPath()
    if (@lenOf(path) > 0) {
        g_app.config = Config.loadFromFile(path)
    }
    initThemeDefaults(g_app.config)
    return @ptrToInt(&g_app)
}

/// Destroy the global app.
export fn cotty_app_free(app: i64) void {
    g_app.surfaces.free()
    g_app.mailbox.free()
}

/// Run one tick — drains the mailbox.
export fn cotty_app_tick(app: i64) void {
    g_app.tick()
}

/// Return the number of open surfaces.
export fn cotty_app_surface_count(app: i64) i64 {
    return g_app.surfaces.count
}

/// Return 1 if the app is still running, 0 otherwise.
export fn cotty_app_is_running(app: i64) i64 {
    if (g_app.running) {
        return 1
    }
    return 0
}

// ============================================================================
// Action queue
// ============================================================================

/// Read and clear the pending action tag. Returns ACTION_NONE if empty.
export fn cotty_app_next_action(app: i64) i64 {
    const tag = g_action_tag
    g_action_tag = ACTION_NONE
    return tag
}

/// Read the payload of the last consumed action.
export fn cotty_app_action_payload(app: i64) i64 {
    return g_action_payload
}

/// Read the surface index of the last consumed action (-1 if none).
export fn cotty_app_action_surface(app: i64) i64 {
    return g_action_surface
}

// ============================================================================
// Surface lifecycle
// ============================================================================

/// Create a new empty surface. Returns an opaque pointer handle.
export fn cotty_surface_new(app: i64) i64 {
    return @ptrToInt(g_app.addSurface())
}

/// Remove a surface by pointer handle.
export fn cotty_surface_free(surface: i64) void {
    g_app.removeSurface(getSurfacePtr(surface))
}

// ============================================================================
// Surface input
// ============================================================================

/// Send a key event to a surface. Routes through keyToAction dispatch.
export fn cotty_surface_key(surface: i64, key: i64, mods: i64) void {
    const event = KeyEvent { key: key, mods: mods }
    const action = keyToAction(event)

    const ptr = getSurfacePtr(surface)

    switch (action) {
        InputAction.insert_char => {
            // Tab → 4 spaces
            if (key == 9) {
                ptr.handleInput(InputAction.insert_char, ' ')
                ptr.handleInput(InputAction.insert_char, ' ')
                ptr.handleInput(InputAction.insert_char, ' ')
                ptr.handleInput(InputAction.insert_char, ' ')
            } else if (key == 13) {
                // Enter → newline
                ptr.handleInput(InputAction.insert_char, '\n')
            } else {
                ptr.handleInput(InputAction.insert_char, key)
            }
            g_action_tag = ACTION_MARK_DIRTY
            g_action_surface = surface
        },
        InputAction.delete_back => {
            ptr.handleInput(InputAction.delete_back, 0)
            g_action_tag = ACTION_MARK_DIRTY
            g_action_surface = surface
        },
        InputAction.delete_forward => {
            ptr.handleInput(InputAction.delete_forward, 0)
            g_action_tag = ACTION_MARK_DIRTY
            g_action_surface = surface
        },
        InputAction.move_left => {
            ptr.handleInput(InputAction.move_left, 0)
        },
        InputAction.move_right => {
            ptr.handleInput(InputAction.move_right, 0)
        },
        InputAction.move_up => {
            ptr.handleInput(InputAction.move_up, 0)
        },
        InputAction.move_down => {
            ptr.handleInput(InputAction.move_down, 0)
        },
        InputAction.move_line_start => {
            ptr.handleInput(InputAction.move_line_start, 0)
        },
        InputAction.move_line_end => {
            ptr.handleInput(InputAction.move_line_end, 0)
        },
        InputAction.page_up => {
            ptr.handleInput(InputAction.page_up, 0)
        },
        InputAction.page_down => {
            ptr.handleInput(InputAction.page_down, 0)
        },
        InputAction.save => {
            g_action_tag = ACTION_MARK_DIRTY
            g_action_surface = surface
        },
        InputAction.quit => {
            g_app.postMessage(Message.quit)
            g_action_tag = ACTION_QUIT
        },
        InputAction.new_surface => {
            g_action_tag = ACTION_NEW_WINDOW
        },
        InputAction.close_surface => {
            g_action_tag = ACTION_CLOSE_SURFACE
            g_action_surface = surface
        },
        else => {},
    }
}

/// Insert raw UTF-8 bytes into a surface.
export fn cotty_surface_text(surface: i64, ptr: *u8, len: i64) void {
    const sptr = getSurfacePtr(surface)
    var i: i64 = 0
    while (i < len) {
        const byte_ptr = @intToPtr(*u8, @ptrToInt(ptr) + i)
        sptr.handleInput(InputAction.insert_char, byte_ptr.*)
        i += 1
    }
    g_action_tag = ACTION_MARK_DIRTY
    g_action_surface = surface
}

/// Load content into a surface, replacing existing buffer.
export fn cotty_surface_load_content(surface: i64, ptr: *u8, len: i64) void {
    const sptr = getSurfacePtr(surface)
    // Reset surface to empty
    sptr.buffer = Buffer.init()
    sptr.cursor = Cursor.init()
    sptr.dirty = false
    // Insert content byte by byte
    var i: i64 = 0
    while (i < len) {
        const byte_ptr = @intToPtr(*u8, @ptrToInt(ptr) + i)
        sptr.handleInput(InputAction.insert_char, byte_ptr.*)
        i += 1
    }
    // Reset cursor to start
    sptr.cursor.offset = 0
    sptr.cursor.line = 0
    sptr.cursor.col = 0
    sptr.dirty = false
}

// ============================================================================
// Surface queries
// ============================================================================

export fn cotty_surface_buffer_len(surface: i64) i64 {
    return getSurfacePtr(surface).buffer.len()
}

export fn cotty_surface_buffer_line_count(surface: i64) i64 {
    return getSurfacePtr(surface).buffer.lineCount()
}

export fn cotty_surface_buffer_line_length(surface: i64, line: i64) i64 {
    return getSurfacePtr(surface).buffer.lineLength(line)
}

export fn cotty_surface_buffer_line_start_offset(surface: i64, line: i64) i64 {
    return getSurfacePtr(surface).buffer.lineStartOffset(line)
}

export fn cotty_surface_buffer_char_at(surface: i64, pos: i64) i64 {
    return getSurfacePtr(surface).buffer.charAt(pos)
}

export fn cotty_surface_cursor_line(surface: i64) i64 {
    return getSurfacePtr(surface).cursor.line
}

export fn cotty_surface_cursor_col(surface: i64) i64 {
    return getSurfacePtr(surface).cursor.col
}

export fn cotty_surface_cursor_offset(surface: i64) i64 {
    return getSurfacePtr(surface).cursor.offset
}

export fn cotty_surface_is_dirty(surface: i64) i64 {
    if (getSurfacePtr(surface).dirty) {
        return 1
    }
    return 0
}

export fn cotty_surface_set_clean(surface: i64) void {
    getSurfacePtr(surface).dirty = false
}

// ============================================================================
// Surface kind
// ============================================================================

/// Return the surface kind: 0 = editor, 1 = terminal.
export fn cotty_surface_kind(surface: i64) i64 {
    return getSurfacePtr(surface).kind
}

// ============================================================================
// Terminal surface lifecycle
// ============================================================================

/// Create a new terminal surface with a shell. Returns an opaque pointer handle.
/// Starts the IO reader thread after the surface is in its final memory location.
export fn cotty_terminal_surface_new(app: i64, rows: i64, cols: i64) i64 {
    const s = g_app.addTerminalSurface(rows, cols)
    // Wire inspector pointer into the parser so VT events are recorded
    s.parser.inspector_ptr = @ptrToInt(&s.inspector)
    // Start IO thread now that the surface is at its final address in the list
    s.startIoThread()
    return @ptrToInt(s)
}

/// Close the PTY and remove a terminal surface.
/// Shutdown sequence: kill child → join IO thread → close PTY → close pipe → destroy mutex.
export fn cotty_terminal_surface_free(surface: i64) void {
    const sptr = getSurfacePtr(surface)
    // Kill child shell — makes PTY master read() return EOF.
    // On macOS, close() on an fd blocked in read() by another thread
    // does NOT reliably wake the read, so we must kill the child first.
    if (sptr.shell.child_pid > 0) {
        kill(sptr.shell.child_pid, 1)  // SIGHUP = 1
        waitpid(sptr.shell.child_pid)
    }
    // Wait for IO thread to exit (fd_read returns 0 now that child is dead)
    sptr.io_thread.join()
    // Close PTY master fd
    sptr.shell.close()
    // Close notification pipe
    fd_close(sptr.notify_pipe_read)
    fd_close(sptr.notify_pipe_write)
    // Destroy mutex
    sptr.terminal_mutex.destroy()
    // Remove from surface list
    g_app.removeSurface(sptr)
}

// ============================================================================
// Terminal thread synchronization
// ============================================================================

/// Lock the terminal mutex. Call before reading terminal state from main thread.
export fn cotty_terminal_lock(surface: i64) void {
    getSurfacePtr(surface).terminal_mutex.lock()
}

/// Unlock the terminal mutex. Call after reading terminal state from main thread.
export fn cotty_terminal_unlock(surface: i64) void {
    getSurfacePtr(surface).terminal_mutex.unlock()
}

/// Return the notification pipe read fd. Main thread monitors this for render signals.
export fn cotty_terminal_notify_fd(surface: i64) i64 {
    return getSurfacePtr(surface).notify_pipe_read
}

// ============================================================================
// Terminal I/O
// ============================================================================

/// Send a key event to a terminal surface.
/// Translates abstract KEY_* constant + mods to VT100 bytes and writes to PTY.
/// Captures sent bytes for the key inspector.
/// Scrolls viewport to bottom on any keypress.
export fn cotty_terminal_key(surface: i64, key: i64, mods: i64) void {
    const sptr = getSurfacePtr(surface)
    sptr.terminal.scrollToBottom()
    captureBegin()
    keyToTerminalBytes(sptr.shell.master_fd, key, mods, sptr.terminal.mode_app_cursor)
    const bytes = captureEnd()
    sptr.inspector.recordKeyEvent(key, mods, bytes)
}

/// Write raw bytes to the terminal's PTY (sends input to the shell).
export fn cotty_terminal_write(surface: i64, ptr: *u8, len: i64) void {
    const sptr = getSurfacePtr(surface)
    fd_write(sptr.shell.master_fd, @ptrToInt(ptr), len)
}

/// Read available bytes from the terminal's PTY into buf.
/// Returns bytes read, 0 on EOF, negative on error/EAGAIN.
export fn cotty_terminal_read(surface: i64, ptr: *u8, len: i64) i64 {
    const sptr = getSurfacePtr(surface)
    return fd_read(sptr.shell.master_fd, @ptrToInt(ptr), len)
}

/// Resize the terminal grid and PTY to new dimensions.
export fn cotty_terminal_resize(surface: i64, rows: i64, cols: i64) void {
    const sptr = getSurfacePtr(surface)
    sptr.terminal.resize(rows, cols)
    sptr.shell.resize(rows, cols)
}

/// Feed raw bytes through the VT parser into the terminal state.
/// Call this after cotty_terminal_read to process shell output.
export fn cotty_terminal_feed(surface: i64, ptr: *u8, len: i64) void {
    const sptr = getSurfacePtr(surface)
    var i: i64 = 0
    while (i < len) {
        const b = @intToPtr(*u8, @ptrToInt(ptr) + i).*
        sptr.parser.feed(sptr.terminal, b)
        i += 1
    }
}

/// Feed a single byte through the VT parser.
/// Avoids Cot-side loop that triggers *Cell heap corruption.
export fn cotty_terminal_feed_byte(surface: i64, b: i64) void {
    const sptr = getSurfacePtr(surface)
    sptr.parser.feed(sptr.terminal, b)
}

// ============================================================================
// Terminal grid queries
// ============================================================================

/// Return the number of rows in the terminal grid.
export fn cotty_terminal_rows(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.grid.rows
}

/// Return the number of columns in the terminal grid.
export fn cotty_terminal_cols(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.grid.cols
}

/// Return the codepoint of the cell at (row, col).
export fn cotty_terminal_cell_codepoint(surface: i64, row: i64, col: i64) i64 {
    return getSurfacePtr(surface).terminal.grid.getCell(row, col).codepoint
}

/// Return the foreground color of the cell at (row, col) as packed RGB.
/// Format: (r << 16) | (g << 8) | b
export fn cotty_terminal_cell_fg(surface: i64, row: i64, col: i64) i64 {
    const c = getSurfacePtr(surface).terminal.grid.getCell(row, col)
    return (c.fg_r << 16) | (c.fg_g << 8) | c.fg_b
}

/// Return the background color of the cell at (row, col) as packed RGB.
/// Format: (r << 16) | (g << 8) | b
export fn cotty_terminal_cell_bg(surface: i64, row: i64, col: i64) i64 {
    const c = getSurfacePtr(surface).terminal.grid.getCell(row, col)
    return (c.bg_r << 16) | (c.bg_g << 8) | c.bg_b
}

/// Return the flags of the cell at (row, col).
export fn cotty_terminal_cell_flags(surface: i64, row: i64, col: i64) i64 {
    return getSurfacePtr(surface).terminal.grid.getCell(row, col).flags
}

// ============================================================================
// Terminal cursor queries
// ============================================================================

/// Return the terminal cursor row.
export fn cotty_terminal_cursor_row(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.cursor_row
}

/// Return the terminal cursor column.
export fn cotty_terminal_cursor_col(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.cursor_col
}

/// Return 1 if the terminal cursor is visible, 0 otherwise.
/// Hides cursor when viewport is scrolled up from the active area.
export fn cotty_terminal_cursor_visible(surface: i64) i64 {
    const sptr = getSurfacePtr(surface)
    if (!sptr.terminal.cursor_visible) { return 0 }
    if (!sptr.terminal.viewportIsBottom()) { return 0 }
    return 1
}

/// Return the PTY master fd (for polling with kqueue/epoll).
export fn cotty_terminal_pty_fd(surface: i64) i64 {
    return getSurfacePtr(surface).shell.master_fd
}

/// Return the child PID of the terminal's shell process.
export fn cotty_terminal_child_pid(surface: i64) i64 {
    return getSurfacePtr(surface).shell.child_pid
}

/// Return a pointer to the visible cells for rendering.
/// Adjusts for viewport position: when scrolled up, returns scrollback rows.
/// Each cell is 8 contiguous i64 fields: codepoint, fg_r, fg_g, fg_b, bg_r, bg_g, bg_b, flags.
/// Stride per cell = 8 * 8 = 64 bytes. Total cells = rows * cols.
export fn cotty_terminal_cells_ptr(surface: i64) i64 {
    const sptr = getSurfacePtr(surface)
    const grid = sptr.terminal.grid
    var row_offset = grid.active_start
    if (sptr.terminal.viewport_row >= 0) {
        row_offset = sptr.terminal.viewport_row
    }
    return grid.cells.items + row_offset * grid.cols * @sizeOf(Cell)
}

// ============================================================================
// Terminal scrollback queries
// ============================================================================

/// Return the number of scrollback rows (lines above the visible area).
export fn cotty_terminal_scrollback_rows(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.grid.active_start
}

/// Return the current viewport row (-1 = following active/bottom).
export fn cotty_terminal_viewport_row(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.viewport_row
}

/// Set the viewport to a specific row. -1 = follow active (bottom).
/// Used by the native scrollbar to scroll to a position.
export fn cotty_terminal_set_viewport(surface: i64, row: i64) void {
    const sptr = getSurfacePtr(surface)
    if (row < 0) {
        sptr.terminal.viewport_row = -1
    } else if (row >= sptr.terminal.grid.active_start) {
        sptr.terminal.viewport_row = -1
    } else {
        sptr.terminal.viewport_row = row
    }
}

// ============================================================================
// Terminal selection
// ============================================================================

/// Selected text buffer — allocated on first use.
var g_sel_buf: i64 = 0
var g_sel_buf_cap: i64 = 0
var g_sel_len: i64 = 0

/// Begin a selection at (row, col).
export fn cotty_terminal_selection_start(surface: i64, row: i64, col: i64) void {
    getSurfacePtr(surface).terminal.selectionStart(row, col)
}

/// Update selection endpoint to (row, col).
export fn cotty_terminal_selection_update(surface: i64, row: i64, col: i64) void {
    getSurfacePtr(surface).terminal.selectionUpdate(row, col)
}

/// Clear the selection.
export fn cotty_terminal_selection_clear(surface: i64) void {
    getSurfacePtr(surface).terminal.selectionClear()
}

/// Return 1 if a selection is active, 0 otherwise.
export fn cotty_terminal_selection_active(surface: i64) i64 {
    if (getSurfacePtr(surface).terminal.sel_active) {
        return 1
    }
    return 0
}

/// Extract selected text into an internal buffer and return the pointer.
/// Call cotty_terminal_selected_text_len to get the byte count.
export fn cotty_terminal_selected_text(surface: i64) i64 {
    // Ensure buffer allocated (64KB)
    if (g_sel_buf == 0) {
        g_sel_buf_cap = 65536
        g_sel_buf = alloc(0, g_sel_buf_cap)
    }
    g_sel_len = getSurfacePtr(surface).terminal.writeSelectedText(g_sel_buf, g_sel_buf_cap)
    return g_sel_buf
}

/// Return the byte length of the last extracted selected text.
export fn cotty_terminal_selected_text_len(surface: i64) i64 {
    return g_sel_len
}

// ============================================================================
// Config accessors
// ============================================================================

/// Return a pointer to the font name string bytes.
export fn cotty_config_font_name() i64 {
    return @ptrOf(g_app.config.font_name)
}

/// Return the byte length of the font name string.
export fn cotty_config_font_name_len() i64 {
    return @lenOf(g_app.config.font_name)
}

/// Return the configured font size.
export fn cotty_config_font_size() i64 {
    return g_app.config.font_size
}

/// Return the configured padding in points.
export fn cotty_config_padding() i64 {
    return g_app.config.padding
}

/// Return the background color red component.
export fn cotty_config_bg_r() i64 {
    return g_app.config.bg_r
}

/// Return the background color green component.
export fn cotty_config_bg_g() i64 {
    return g_app.config.bg_g
}

/// Return the background color blue component.
export fn cotty_config_bg_b() i64 {
    return g_app.config.bg_b
}

/// Return the foreground color red component.
export fn cotty_config_fg_r() i64 {
    return g_app.config.fg_r
}

/// Return the foreground color green component.
export fn cotty_config_fg_g() i64 {
    return g_app.config.fg_g
}

/// Return the foreground color blue component.
export fn cotty_config_fg_b() i64 {
    return g_app.config.fg_b
}

/// Return the cursor color red component.
export fn cotty_config_cursor_r() i64 {
    return g_app.config.cursor_r
}

/// Return the cursor color green component.
export fn cotty_config_cursor_g() i64 {
    return g_app.config.cursor_g
}

/// Return the cursor color blue component.
export fn cotty_config_cursor_b() i64 {
    return g_app.config.cursor_b
}

/// Return the selection background red component.
export fn cotty_config_sel_bg_r() i64 {
    return g_app.config.sel_bg_r
}

/// Return the selection background green component.
export fn cotty_config_sel_bg_g() i64 {
    return g_app.config.sel_bg_g
}

/// Return the selection background blue component.
export fn cotty_config_sel_bg_b() i64 {
    return g_app.config.sel_bg_b
}

/// Return the selection foreground red component.
export fn cotty_config_sel_fg_r() i64 {
    return g_app.config.sel_fg_r
}

/// Return the selection foreground green component.
export fn cotty_config_sel_fg_g() i64 {
    return g_app.config.sel_fg_g
}

/// Return the selection foreground blue component.
export fn cotty_config_sel_fg_b() i64 {
    return g_app.config.sel_fg_b
}

// ============================================================================
// Mouse tracking
// ============================================================================

/// Return 1 if alt screen is active, 0 otherwise.
export fn cotty_terminal_alt_screen(surface: i64) i64 {
    if (getSurfacePtr(surface).terminal.mode_alt_screen) { return 1 }
    return 0
}

/// Return the current mouse tracking mode (0=off, 1000/1002/1003).
export fn cotty_terminal_mouse_mode(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.mode_mouse_tracking
}

/// Return the current mouse format (0=normal, 1006=SGR).
export fn cotty_terminal_mouse_format(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.mode_mouse_format
}

/// Send a mouse event to the terminal's PTY.
/// No-ops if mouse tracking is disabled.
/// button: 0=left, 1=middle, 2=right, 32=drag, 64=wheel up, 65=wheel down.
/// col, row: 1-indexed. pressed: 1=press/wheel, 0=release.
export fn cotty_terminal_mouse_event(surface: i64, button: i64, col: i64, row: i64, pressed: i64) void {
    const sptr = getSurfacePtr(surface)
    if (sptr.terminal.mode_mouse_tracking == 0) { return }
    mouseToTerminalBytes(sptr.shell.master_fd, button, col, row, pressed)
}

/// Handle a scroll wheel event. All logic lives in Cot (ported from Ghostty).
/// Swift just forwards raw deltas — no logic in the platform layer.
export fn cotty_terminal_scroll(surface: i64, delta: i64, precise: i64, cell_height: i64, col: i64, row: i64) void {
    const sptr = getSurfacePtr(surface)
    sptr.terminal.scrollEvent(sptr.shell.master_fd, delta, precise, cell_height, col, row)
}

// ============================================================================
// Terminal cursor shape
// ============================================================================

/// Return the cursor shape (0=default, 1=blinking block, 2=steady block,
/// 3=blinking underline, 4=steady underline, 5=blinking bar, 6=steady bar).
export fn cotty_terminal_cursor_shape(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.cursor_shape
}

// ============================================================================
// Terminal title
// ============================================================================

/// Return a pointer to the terminal title bytes.
export fn cotty_terminal_title(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.title_buf
}

/// Return the byte length of the terminal title.
export fn cotty_terminal_title_len(surface: i64) i64 {
    return getSurfacePtr(surface).terminal.title_len
}

// ============================================================================
// Terminal bell
// ============================================================================

/// Return 1 if a bell is pending and clear the flag, 0 otherwise.
export fn cotty_terminal_bell(surface: i64) i64 {
    const sptr = getSurfacePtr(surface)
    if (sptr.terminal.bell_pending) {
        sptr.terminal.bell_pending = false
        return 1
    }
    return 0
}

// ============================================================================
// Terminal bracketed paste and focus events
// ============================================================================

/// Return 1 if bracketed paste mode is enabled, 0 otherwise.
export fn cotty_terminal_bracketed_paste_mode(surface: i64) i64 {
    if (getSurfacePtr(surface).terminal.mode_bracketed_paste) { return 1 }
    return 0
}

/// Return 1 if focus event mode is enabled, 0 otherwise.
export fn cotty_terminal_focus_event_mode(surface: i64) i64 {
    if (getSurfacePtr(surface).terminal.mode_focus_events) { return 1 }
    return 0
}

// ============================================================================
// Per-Surface Inspector
// ============================================================================

/// Toggle the inspector panel for a surface.
export fn cotty_inspector_toggle(surface: i64) void {
    const sptr = getSurfacePtr(surface)
    sptr.inspector.toggle()
}

/// Return 1 if the inspector is active, 0 otherwise.
export fn cotty_inspector_active(surface: i64) i64 {
    if (getSurfacePtr(surface).inspector.active) { return 1 }
    return 0
}

/// Return the number of rows in the inspector grid.
export fn cotty_inspector_rows(surface: i64) i64 {
    return getSurfacePtr(surface).inspector.rows
}

/// Return the number of columns in the inspector grid.
export fn cotty_inspector_cols(surface: i64) i64 {
    return getSurfacePtr(surface).inspector.cols
}

/// Return a pointer to the inspector cells buffer.
export fn cotty_inspector_cells_ptr(surface: i64) i64 {
    return getSurfacePtr(surface).inspector.grid.cells.items
}

/// Resize the inspector grid.
export fn cotty_inspector_resize(surface: i64, rows: i64, cols: i64) void {
    getSurfacePtr(surface).inspector.resize(rows, cols)
}

/// Switch the inspector to a different panel (0=Screen, 1=Modes, 2=Keyboard, 3=Terminal IO).
export fn cotty_inspector_set_panel(surface: i64, panel: i64) void {
    getSurfacePtr(surface).inspector.setPanel(panel)
}

/// Scroll the inspector panel.
export fn cotty_inspector_scroll(surface: i64, delta: i64) void {
    getSurfacePtr(surface).inspector.scroll(delta)
}

/// Return the total scrollable content rows for the current panel.
export fn cotty_inspector_content_rows(surface: i64) i64 {
    return getSurfacePtr(surface).inspector.contentRows()
}

/// Return the current scroll offset for the active panel.
export fn cotty_inspector_scroll_offset(surface: i64) i64 {
    return getSurfacePtr(surface).inspector.scrollOffset()
}

/// Set the absolute scroll offset for the active panel.
export fn cotty_inspector_set_scroll(surface: i64, offset: i64) void {
    getSurfacePtr(surface).inspector.setScrollOffset(offset)
}

/// Rebuild the Screen/Modes panels with current terminal state.
/// Must be called under terminal lock.
export fn cotty_inspector_rebuild_terminal_state(surface: i64) void {
    const sptr = getSurfacePtr(surface)
    if (!sptr.inspector.active) { return }
    if (sptr.inspector.panel == PANEL_SCREEN) {
        sptr.inspector.rebuildScreenFrom(sptr.terminal)
    } else if (sptr.inspector.panel == PANEL_MODES) {
        sptr.inspector.rebuildModesFrom(sptr.terminal)
    }
}

